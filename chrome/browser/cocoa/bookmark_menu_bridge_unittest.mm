// Copyright (c) 2009 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#import <AppKit/AppKit.h>
#include "chrome/app/chrome_dll_resource.h"
#include "chrome/browser/browser.h"
#include "chrome/browser/cocoa/bookmark_menu_bridge.h"
#include "chrome/browser/cocoa/browser_test_helper.h"
#include "testing/gtest/include/gtest/gtest.h"

// TODO(jrg): see refactor comment in bookmark_bar_state_controller_unittest.mm
class BookmarkMenuBridgeTest : public testing::Test {
 public:

  // We are a friend of BookmarkMenuBridge (and have access to
  // protected methods), but none of the classes generated by TEST_F()
  // are.  This (and AddNodeToMenu()) are simple wrappers to let
  // derived test classes have access to protected methods.
  void ClearBookmarkMenu(BookmarkMenuBridge* bridge, NSMenu* menu) {
    bridge->ClearBookmarkMenu(menu);
  }

  void AddNodeToMenu(BookmarkMenuBridge* bridge, BookmarkNode* root,
                     NSMenu* menu) {
    bridge->AddNodeToMenu(root, menu);
  }

  NSMenuItem* AddItemToMenu(NSMenu *menu, NSString *title, NSInteger tag) {
    NSMenuItem *item = [[[NSMenuItem alloc] initWithTitle:title action:NULL
                                            keyEquivalent:@""] autorelease];
    [item setTag:tag];
    [menu addItem:item];
    return item;
  }

  BrowserTestHelper browser_test_helper_;
};


// Test that ClearBookmarkMenu() removes all bookmark menus.
TEST_F(BookmarkMenuBridgeTest, TestClearBookmarkMenu) {
  Browser* browser = browser_test_helper_.GetBrowser();
  BookmarkMenuBridge* bridge = new BookmarkMenuBridge(browser);
  EXPECT_TRUE(bridge);

  NSMenu* menu = [[[NSMenu alloc] initWithTitle:@"foo"] autorelease];

  AddItemToMenu(menu, @"hi mom", IDC_BOOKMARK_MENUITEM_BASE);
  AddItemToMenu(menu, @"not", 0);
  NSMenuItem* item = AddItemToMenu(menu, @"hi mom", 0);
  [item setSubmenu:[[[NSMenu alloc] initWithTitle:@"bar"] autorelease]];
  AddItemToMenu(menu, @"not", 0);

  ClearBookmarkMenu(bridge, menu);

  // Make sure all IDC_BOOKMARK items are removed, and all items with
  // submenus removed.
  EXPECT_EQ(2, [menu numberOfItems]);
  for (NSMenuItem *item in [menu itemArray]) {
    EXPECT_TRUE([[item title] isEqual:@"not"]);
  }
}

// Test that AddNodeToMenu() properly adds bookmark nodes as menus,
// including the recursive case.
TEST_F(BookmarkMenuBridgeTest, TestAddNodeToMenu) {
  Browser* browser = browser_test_helper_.GetBrowser();
  Profile* profile = browser_test_helper_.GetProfile();

  BookmarkMenuBridge *bridge = new BookmarkMenuBridge(browser);
  EXPECT_TRUE(bridge);

  NSMenu* menu = [[[NSMenu alloc] initWithTitle:@"foo"] autorelease];

  BookmarkModel* model = new BookmarkModel(profile);
  BookmarkNode* root = new BookmarkNode(model, GURL());
  EXPECT_TRUE(model && root);

  // 3 nodes; middle one has a child
  BookmarkNode* node = NULL;
  for (int x = 0; x < 3; x++) {
    node = new BookmarkNode(model, (x==1 ? GURL() : GURL("http://foo")));
    root->Add(x, node);
  }
  node = new BookmarkNode(model, GURL("http://sub"));
  root->GetChild(1)->Add(0, node);

  // Add to the NSMenu, then confirm it looks good
  AddNodeToMenu(bridge, root, menu);

  EXPECT_EQ(3, [menu numberOfItems]);
  for (int x=0; x < 3; x++) {
    NSMenuItem* item = [menu itemAtIndex:x];
    NSInteger tag = [item tag];
    EXPECT_TRUE((tag >= IDC_BOOKMARK_MENUITEM_BASE) &&
                (tag < IDC_BOOKMARK_MENUITEM_MAX));
  }
  EXPECT_EQ(NO, [[menu itemAtIndex:0] hasSubmenu]);
  EXPECT_EQ(NO, [[menu itemAtIndex:2] hasSubmenu]);
  NSMenuItem* middle = [menu itemAtIndex:1];
  EXPECT_NE(NO, [middle hasSubmenu]);
  EXPECT_EQ(1, [[middle submenu] numberOfItems]);

  delete root;  // deletes all its kids
  delete model;
}
