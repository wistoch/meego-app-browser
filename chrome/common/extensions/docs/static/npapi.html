<div id="pageData-title" class="pageData">NPAPI Plugins</div>

<p>
Leveraging HTML and JavaScript
makes developing new extensions really easy,
but what if you have existing legacy or proprietary code
that you want to reuse in your extension?
You can bundle an NPAPI plugin with your extension,
allowing you to call into native binary code from JavaScript.
</p>

<h2>Details</h2>

<p>
How to develop an NPAPI plugin is outside the scope of this document.
See <a href="https://developer.mozilla.org/en/Plugins">Mozilla's
NPAPI plugin reference</a> for information on how to do that.
</p>

<p>
Once you have an NPAPI plugin,
follow these steps to get your extension using it.
</p>

<ol>
  <li>
    Add a section to your extension's <code>manifest.json</code>
    that describes where to find the plugin,
    along with other properties about it:

<pre>{
  "name": "My extension",
  ...
<b>  "plugins": [
    { "path": "content_plugin.dll", "public": true },
    { "path": "extension_plugin.dll" }
  ]</b>
}</pre>

    <p>
    The "path" property specifies the path to your plugin,
    relative to the manifest file.
    The "public" property specifies whether
    your plugin can be accessed by regular web pages;
    the default is false,
    meaning only your extension can load the plugin.
    </p>
   </li>

   <li>
     Create an HTML file that loads your plugin by mime-type.
     Assuming your mime-type is "application/x-my-extension":

<pre>
&lt;embed type="application/x-my-extension" id="pluginId"></embed>
&lt;script>
  var plugin = document.getElementById("pluginId");
  var result = plugin.myPluginMethod();  // call a method in your plugin
  console.log("my plugin returned: " + result);
&lt;/script></pre>

     <p>
     This can be inside a background page
     or any other HTML page used by your extension.
     If your plugin is "public",
     you can even use a content script to programmatically
     insert your plugin into a web page.
     </p>
