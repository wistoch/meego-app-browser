<script>
var getURL = chrome.extension.getURL;
var expectedEventData;
var capturedEventData;
var startTime;

function expect(data, filter, extraInfoSpec) {
  startTime = new Date();
  expectedEventData = data;
  capturedEventData = [];
  removeListeners();
  initListeners(filter, extraInfoSpec);
}

function checkExpectations() {
  if (capturedEventData.length < expectedEventData.length) {
    return;
  }
  // TODO(mpcomplete): allow partial ordering of events
  chrome.test.assertEq(JSON.stringify(expectedEventData),
      JSON.stringify(capturedEventData));
  chrome.test.succeed();
}

function captureEvent(name, details) {
  // Basic sanity check for timeStamp.
  var now = new Date();
  var requestTime = new Date(details.timeStamp);
  chrome.test.assertTrue(startTime <= requestTime,
      "requestTime: " + requestTime.getTime() +
      " is before startTime: " + startTime.getTime());
  // TODO(mpcomplete): why is requestTime sometimes later than now?
//  chrome.test.assertTrue(requestTime <= now,
//      "requestTime: " + requestTime.getTime() +
//      " is after now: " + now.getTime());
  delete details.requestId;
  delete details.timeStamp;
  capturedEventData.push([name, details]);
  checkExpectations();
}

function initListeners(filter, extraInfoSpec) {
  chrome.experimental.webRequest.onBeforeRequest.addListener(
      function(details) {
    captureEvent("onBeforeRequest", details);
    return {cancel: true};  // no effect unless event is blocking.
  }, filter, extraInfoSpec);
  chrome.experimental.webRequest.onRequestSent.addListener(
      function(details) {
    captureEvent("onRequestSent", details);
    return {cancel: true};
  }, filter, extraInfoSpec);
  chrome.experimental.webRequest.onHeadersReceived.addListener(
      function(details) {
    captureEvent("onHeadersReceived", details);
    return {cancel: true};
  }, filter, extraInfoSpec);
  chrome.experimental.webRequest.onBeforeRedirect.addListener(
      function(details) {
    captureEvent("onBeforeRedirect", details);
    return {cancel: true};
  }, filter, extraInfoSpec);
  chrome.experimental.webRequest.onCompleted.addListener(
      function(details) {
    captureEvent("onCompleted", details);
    return {cancel: true};
  }, filter, extraInfoSpec);
  chrome.experimental.webRequest.onErrorOccurred.addListener(
      function(details) {
    captureEvent("onErrorOccurred", details);
    return {cancel: true};
  }, filter, extraInfoSpec);
}

function removeListeners() {
  function helper(event) {
    // Note: We're poking at the internal event data, but it's easier than
    // the alternative. If this starts failing, we just need to update this
    // helper.
    for (var cb in event.callbackMap_) {
      event.removeListener(cb);
    }
    chrome.test.assertEq(0, event.subEvents_.length);
  }
  helper(chrome.experimental.webRequest.onBeforeRequest);
  helper(chrome.experimental.webRequest.onRequestSent);
  helper(chrome.experimental.webRequest.onHeadersReceived);
  helper(chrome.experimental.webRequest.onBeforeRedirect);
  helper(chrome.experimental.webRequest.onCompleted);
  helper(chrome.experimental.webRequest.onErrorOccurred);
}

chrome.tabs.getSelected(null, function(tab) {
  var tabId = tab.id;

  chrome.test.runTests([
    // Navigates to a blank page.
    function simpleLoad() {
      expect([
        [ "onBeforeRequest",
          {
            method: "GET",
            tabId: tabId,
            type: "main_frame",
            url: getURL("simpleLoad/a.html")
          }
        ],
      ]);
      chrome.tabs.update(tabId, { url: getURL("simpleLoad/a.html") });
    },

    // Navigates to a page with subresources.
    // TODO(mpcomplete): add multiple subresources; requires support for
    // recognizing partial ordering.
    function complexLoad() {
      expect([
        [ "onBeforeRequest",
          {
            method: "GET",
            tabId: tabId,
            type: "main_frame",
            url: getURL("complexLoad/a.html")
          }
        ],
        [ "onBeforeRequest",
          {
            method: "GET",
            tabId: tabId,
            type: "sub_frame",
            url: getURL("complexLoad/b.html")
          }
        ],
        [ "onBeforeRequest",
          {
            method: "GET",
            tabId: tabId,
            type: "image",
            url: getURL("complexLoad/b.jpg")
          }
        ],
      ]);
      chrome.tabs.update(tabId, { url: getURL("complexLoad/a.html") });
    },

    // Navigates to a page with subresources, with a blocking handler that
    // cancels the page request. The page will not load, and we should not
    // see the subresources.
    function complexLoadBlocking() {
      expect([
        [ "onBeforeRequest",
          {
            method: "GET",
            tabId: tabId,
            type: "main_frame",
            url: getURL("complexLoad/a.html")
          }
        ]
      ], {}, ["blocking"]);
      chrome.tabs.update(tabId, { url: getURL("complexLoad/a.html") });
    },

    // Loads several resources, but should only see the complexLoad main_frame
    // and image due to the filter.
    function complexLoadFiltered() {
      expect([
        [ "onBeforeRequest",
          {
            method: "GET",
            tabId: tabId,
            type: "main_frame",
            url: getURL("complexLoad/a.html")
          }
        ],
        [ "onBeforeRequest",
          {
            method: "GET",
            tabId: tabId,
            type: "image",
            url: getURL("complexLoad/b.jpg")
          }
        ]
      ], {urls: [getURL("complexLoad/*")],
          types: ["main_frame", "image"],
          tabId: tabId}, []);
      chrome.tabs.create({ url: getURL("simpleLoad/a.html") },
          function(newTab) {
        chrome.tabs.remove(newTab.id);
        chrome.tabs.update(tabId, { url: getURL("complexLoad/a.html") });
      });
    },
  ]);
});
</script>
