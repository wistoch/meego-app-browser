# Copyright (c) 2008 The Chromium Authors. All rights reserved.
# Use of this source code is governed by a BSD-style license that can be
# found in the LICENSE file.

import fnmatch
import os
import re
import shutil
import subprocess
import utils

Import('env')

env = env.Clone(
    FF_XPI = '$INSTALLER_BASEDIR/${INSTALLER_BASENAME}.xpi',
    WIN32_INSTALLER_MSI = '$INSTALLER_BASEDIR/${INSTALLER_BASENAME}.msi',
    WINCE_INSTALLER_CAB = '$INSTALLER_BASEDIR/${INSTALLER_BASENAME}.cab',

    SF_INSTALLER_PLUGIN_BUNDLE = '$INSTALLER_BASEDIR/Safari/StatsPane.bundle',
    SF_PLUGIN_BUNDLE = '$INSTALLER_BASEDIR/Safari/Gears.bundle',
    SF_PLUGIN_PROXY_BUNDLE = '$INSTALLER_BASEDIR/Safari/Gears.plugin',
    SF_INPUTMANAGER_BUNDLE = '$INSTALLER_BASEDIR/Safari/GearsEnabler',
    SF_INSTALLER_PKG = '$INSTALLER_BASEDIR/Safari/Gears.pkg',

    FF2_MODULE = '${SHLIBPREFIX}gears_ff2${SHLIBSUFFIX}',
    MODULE = '${SHLIBPREFIX}gears${SHLIBSUFFIX}',
    WINCE_SETUP = '${SHLIBPREFIX}setup${SHLIBSUFFIX}',
)

if env['OS'] in ['win32', 'wince']:
  env.Append(DATE = 'echo %DATE%.%TIME%')
else:
  env.Append(DATE = 'date')

def GetInputs(var): return utils.GetInputs(var, env)

def Shell(cmd):
  """Execute a shell command and return the output."""
  cmd[0] = env.Entry(cmd[0]).abspath
  cmd = env.subst(cmd)
  return subprocess.Popen(
      cmd, shell=True, stdout=subprocess.PIPE).communicate()[0]

if env['OS'] == 'win32':
  def GGUIDGen(value):
    """Generate a GGUID for the given value."""
    return Shell(['$GGUIDGEN', '$NAMESPACE_GUID', value + '-$VERSION'])
  env.Replace(
      GGUIDGEN = '#/$OPEN_DIR/tools/gguidgen.exe',
      NAMESPACE_GUID = '36F65206-5D4E-4752-9D52-27708E10DA79',
# MSI version numbers must have the form <major>.<minor>.<build>. To meet this,
# we combine our build and patch version numbers like so:
# MSI_VERSION = <major>.<minor>.<BUILD * 100 + PATCH>.
# Note: This assumes that the BUILD and PATCH variables adhere to the range
# requirements in version.mk. See comments in version.mk for more details.
      MSI_BUILD = eval(env.subst('$BUILD * 100 + $PATCH')),
      MSI_VERSION = '${MAJOR}.${MINOR}.${MSI_BUILD}',
  )

  # Building wxiobjs with candle
  env.Replace(
      CANDLEDEFPREFIX = '-d',
      CANDLEDEFSUFFIX = '',
      _CANDLEDEFFLAGS = ('${_defines(CANDLEDEFPREFIX, CANDLEDEFINES, '
                         'CANDLEDEFSUFFIX, __env__)}'),
      CANDLECOM = 'candle.exe -out $TARGET $SOURCE ${_CANDLEDEFFLAGS}',
  )
  env.Append(
# Note: Since light.exe is run from $OPEN_DIR, candle.exe must generate
# output with paths relative to that dir.
      SCONS_DIR = '..',  # the scons dir relative to OPEN_DIR
# You can change the names of ProductId vars, but NEVER change their values!
      CANDLEDEFINES = [
          ('OurWin32ProductId',
            GGUIDGen('OUR_PRODUCT_ID')),
          ('OurComponentGUID_FFComponentsDirFiles',
            GGUIDGen('OUR_COMPONENT_GUID_FF_COMPONENTS_DIR_FILES')),
          ('OurComponentGUID_FFContentDirFiles',
            GGUIDGen('OUR_COMPONENT_GUID_FF_CONTENT_DIR_FILES')),
          ('OurComponentGUID_FFDirFiles',
            GGUIDGen('OUR_COMPONENT_GUID_FF_DIR_FILES')),
          ('OurComponentGUID_FFLibDirFiles',
            GGUIDGen('OUR_COMPONENT_GUID_FF_LIB_DIR_FILES')),
          ('OurComponentGUID_FFRegistry',
            GGUIDGen('OUR_COMPONENT_GUID_FF_REGISTRY')),
          ('OurComponentGUID_IEFiles',
            GGUIDGen('OUR_COMPONENT_GUID_IE_FILES')),
          ('OurComponentGUID_IERegistry',
            GGUIDGen('OUR_COMPONENT_GUID_IE_REGISTRY')),
          ('OurComponentGUID_SharedFiles',
            GGUIDGen('OUR_COMPONENT_GUID_SHARED_FILES')),
          ('OurComponentGUID_SharedVersionedFiles',
            GGUIDGen('OUR_COMPONENT_GUID_SHARED_VERSIONED_FILES')),
          ('OurComponentGUID_SharedRegistry',
            GGUIDGen('OUR_COMPONENT_GUID_SHARED_REGISTRY')),
          ('OurNpapiProductId',
            GGUIDGen('OUR_2ND_PRODUCT_ID')),
          ('OurComponentGUID_NpapiFiles',
            GGUIDGen('OUR_COMPONENT_GUID_NPAPI_FILES')),
          ('OurComponentGUID_NpapiRegistry',
            GGUIDGen('OUR_COMPONENT_GUID_NPAPI_REGISTRY')),
          ('OurMsiVersion', '$MSI_VERSION'),
          ('OurCommonPath', '$COMMON_OUTDIR'),
          ('OurIEPath', '$IE_OUTDIR'),
          ('OurIpcTestPath', '$BASE_OUTDIR/common'),
          ('OurFFPath',
            '$BASE_OUTDIR/$INSTALLER_BASEDIR/$INSTALLER_BASENAME'),
          ('OurNpapiPath', '$NPAPI_OUTDIR'),
      ]
  )
  wix_langs = [re.sub('-', '_', lang) for lang in env['I18N_LANGS']]
  env.Append(
      CANDLEDEFINES =
        [('OurComponentGUID_FFLang' + lang + 'DirFiles',
           GGUIDGen('OUR_COMPONENT_GUID_FF_' + lang + '_DIR_FILES'))
         for lang in wix_langs],
  )

def SafeMkdir(dir):
  """Like the builtin Mkdir, but doesn't fail if the dir exists."""
  def Func(target, source, env):
    dir_subst = env.subst(dir, target=target)
    if not os.path.exists(dir_subst):
      os.makedirs(dir_subst)
    return 0
  return Action(Func, 'SafeMkdir("' + dir + '")')

def RecursiveDelete(pattern):
  """Recursively deletes directories matching a pattern."""
  def Func(target, source, env):
    # strip off '.dir' suffix
    target_dir = env.subst('${TARGET.base}', target=target)
    for root, dirs, files in os.walk(target_dir):
      if fnmatch.fnmatch(os.path.normpath(root), pattern):
        print 'Deleting', root
        shutil.rmtree(root)
    return 0
  return Action(Func, 'RecursiveDelete("' + pattern + '")')

def ToUnixPath(path):
  """Converts windows-style \ to unix-style /."""
  return re.sub(r'\\', r'/', path)

def DirBuilder(env, dirtarget, dirsrcs):
  """Builder that makes a directory tree by copying source files to
  corresponding locations inside 'dirtarget'.  'dirsrcs' specifies the list of
  mappings from source file/directory to the target location.  It's formatted
  like:
    (<target file or dir>, <list of source files>)

  Note: source files that come from an output directory must be explicitly
  specified relative to the toplevel dir '#'.
  Note: as shorthand, if the target ends with a '/', then the sources will
  be placed into that dir.  Otherwise, source is renamed into the target.
  """

  srcs = []
  actions = [Delete('${TARGET.base}')]
  for target, sources in dirsrcs:
    srcs += sources

    target_is_dir = target.endswith('/')
    if target_is_dir:
      actions.append(SafeMkdir('${TARGET.base}/' + target))
    else:
      actions.append(SafeMkdir('${TARGET.base}/' + os.path.dirname(target)))
    for source in sources:
      source = env.subst(str(source))

      # HACK: Compensate for the workaround below.  We want the .dir file
      # to be the dependency to the Command() builder, but we want to copy
      # the actual directory - so strip the extension here.
      if source.endswith('.dir'):
        source = source[:-4]

      if target_is_dir:
        actions.append(
            Copy('${TARGET.base}/' + target + os.path.basename(source),
                 source))
      else:
        actions.append(Copy('${TARGET.base}/' + target, source))

  # Remove any .svn directories that were copied.
  actions.append(RecursiveDelete('*/.svn'))

  # HACK: Workaround for bug in scons where directories aren't checked for
  # dependency changes.  Instead, we make a temp file the target, and ensure
  # that that file changes everytime we execute these actions.
  # See http://scons.tigris.org/issues/show_bug.cgi?id=2261
  actions += ['$DATE > ${TARGET}']
  return env.Command(dirtarget + '.dir', srcs, actions)
env.AddMethod(DirBuilder)

def FirefoxInstaller(env):
  # This step is a little hackish.
  # Why: We want to copy files from both the build and source dirs.  We have
  # to be explicit about which tree to pull from, because otherwise scons gets
  # confused - specifically, when copying a directory from the source dir,
  # scons uses the build dir's version instead. 
  # How: We specify "*_OUTDIR" for outputs to pull from the build dir.
  # However, this won't work as an input to a builder, so we strip that off
  # when passing to Command().  The Copy action, however, receives the full
  # qualified path, since it knows nothing about variant build dirs.
  dirsrcs = [
      ('/', ['$FF3_OUTDIR/genfiles/install.rdf',
             '$FF3_OUTDIR/genfiles/chrome.manifest']),
      ('lib/', ['$OPEN_DIR/base/firefox/static_files/lib/updater.js']),
      ('chrome/chromeFiles/content/',
          GetInputs('$FF3_RESOURCES $COMMON_RESOURCES')),
      ('chrome/chromeFiles/locale', ['$FF3_OUTDIR/genfiles/i18n']),
      ('components/',
          ['$FF3_OUTDIR/gears.xpt',
           '$OPEN_DIR/base/firefox/static_files/components/bootstrap.js']),
      ('components/$FF2_MODULE', ['$FF2_OUTDIR/$MODULE']),
      ('components/$MODULE', ['$FF3_OUTDIR/$MODULE']),
  ]

  if env['USING_CCTESTS']:
    dirsrcs += [
        ('components/', ['$COMMON_OUTDIR/ipc_test${PROGSUFFIX}']),
    ]
  if env['OS'] != 'win32':
    # TODO(playmobil): Inspector should be located in extensions dir on win32.
    dirsrcs += [
        ('resources/inspector', [env.Dir('$OPEN_DIR/inspector')]),
        ('resources/inspector/common/', ['$OPEN_DIR/sdk/gears_init.js',
                                         '$OPEN_DIR/sdk/samples/sample.js']),
    ]
  if env['MODE'] == 'dbg' and env['OS'] in ['win32', 'wince']:
    dirsrcs += [
        ('components/gears_ff2.pdb', ['$FF2_OUTDIR/gears.pdb']),
        ('components/gears.pdb', ['$FF3_OUTDIR/gears.pdb']),
    ]
  # TODO: notifier, os x

  dir = env.DirBuilder('$INSTALLER_BASEDIR/${INSTALLER_BASENAME}', dirsrcs)
  actions = [
      # Mark files writeable to allow .xpi rebuilds
      'chmod -R 777 ${SOURCE.base}',
      '(cd ${SOURCE.base} && zip -r ../${TARGET.file} .)'
  ]

  return env.Command('$FF_XPI', dir, actions)
env.AddMethod(FirefoxInstaller)

def Win32Installer(env):
  wxiobj = env.Command(
      '$COMMON_GENFILES_DIR/win32_msi.wxiobj',
      '$COMMON_GENFILES_DIR/win32_msi.wxs',
      '$CANDLECOM')
  # TODO(mpcomplete): remove this if/when the notifier goes away.  This
  # creates fake targets to satisfy the installer build.
  notifier = env.Command(
      [
          '$COMMON_OUTDIR/notifier.exe',
          '$COMMON_OUTDIR/notifier.dll',
          '$COMMON_OUTDIR/notifier_test.exe'
      ], [],
      'touch $TARGETS')
  # light.exe must be run from $OPEN_DIR
  msi = env.Command(
      '$WIN32_INSTALLER_MSI',
      [wxiobj, notifier, '$FF_XPI', '$IE_OUTDIR/$MODULE',
       '$NPAPI_OUTDIR/$MODULE'],
      'cd $OPEN_DIR && light.exe -out ${TARGET.abspath} ${SOURCES[0].abspath}')
  return msi
env.AddMethod(Win32Installer)

def WinCEInstaller(env):
  env['ToUnixPath'] = ToUnixPath
  inf_outdir = ToUnixPath(env.subst('$IE_OUTDIR'))
  inf = env.Command(
      '$COMMON_GENFILES_DIR/wince_cab_fixed.inf',
      '$COMMON_GENFILES_DIR/wince_cab.inf',
      'sed -e "s#bin-....wince-arm.ie.#' + inf_outdir + '#g" $SOURCE > $TARGET')
  cab = env.Command(
      '$WINCE_INSTALLER_CAB',
      [inf, '$IE_OUTDIR/$MODULE', '$IE_OUTDIR/$WINCE_SETUP'],
      ['cabwiz ${ToUnixPath(str(SOURCE))} /compress'
       ' /err ${SOURCES[0].base}.log',
       Copy('$TARGET', '${SOURCE.base}.CAB')])
  return cab
env.AddMethod(WinCEInstaller)

def SafariPluginBundle(env):
  """This is the actual gears plugin bundle for Safari."""
  dirsrcs = [
      ('Contents/', ['$SF_OUTDIR/genfiles/Info.plist']),
      ('Contents/Resources/English.lproj/InfoPlist.strings',
          ['$OPEN_DIR/tools/osx/English.lproj/InfoPlist.strings']),
      ('Contents/Resources/', env.Glob('$OPEN_DIR/ui/safari/*.nib')),
      # TODO(mpcomplete): crash sendor/inspector, launchurl
      ('Contents/MacOS/', ['$SF_OUTDIR/$MODULE']), 
  ]

  if env['USING_CCTESTS']:
    dirsrcs += [
        ('Contents/Resources/', ['$COMMON_OUTDIR/ipc_test${PROGSUFFIX}']),
    ]

  return env.DirBuilder('${SF_PLUGIN_BUNDLE}', dirsrcs)
env.AddMethod(SafariPluginBundle)

def SafariPluginProxyBundle(env):
  """This is a proxy plugin which simply loads gears into Safari and keeps
  it in memory. It exists so that gears doesn't unload when Safari wants us
  to, since that causes crashes."""
  plugin = env.SafariPluginBundle()
  dirsrcs = [
      ('Contents/', ['$SF_OUTDIR/genfiles/Info.plist']),
      ('Contents/MacOS/${SHLIBPREFIX}gears${SHLIBSUFFIX}',
          ['$SF_OUTDIR/${SHLIBPREFIX}gears_proxy${SHLIBSUFFIX}']), 
      ('Contents/Resources/', ['$BASE_OUTDIR/' + str(plugin[0])]),
      ('Contents/Resources/', ['$OPEN_DIR/tools/osx/uninstall.command']),
  ]

  return env.DirBuilder('${SF_PLUGIN_PROXY_BUNDLE}', dirsrcs)
env.AddMethod(SafariPluginProxyBundle)

def SafariInstallerPluginBundle(env):
  dirsrcs = [
      ('Contents/Info.plist',
          ['$OPEN_DIR/base/safari/advanced_stats_sheet.plist']),
      ('Contents/MacOS/',
          ['$COMMON_OUTDIR/${SHLIBPREFIX}stats_pane${SHLIBSUFFIX}']), 
      ('Contents/Resources/AdvancedStatsSheet.nib',
          [env.Dir('$OPEN_DIR/base/safari/advanced_stats_sheet.nib')]),
  ]

  return env.DirBuilder('${SF_INSTALLER_PLUGIN_BUNDLE}', dirsrcs)
env.AddMethod(SafariInstallerPluginBundle)

def SafariInstallerPackage(env):
  proxy = env.SafariPluginProxyBundle()
  pkg = env.Iceberg(env.Dir('${SF_INSTALLER_PKG}'),
      [
          '$SF_OUTDIR/genfiles/installer.packproj',
          '$BASE_OUTDIR/' + str(proxy[0]),
      ])
  return pkg
env.AddMethod(SafariInstallerPackage)

def SafariInputManagerBundle(env):
  info = env.Command('$SF_OUTDIR/genfiles/Enabler-Info.plist',
      '$OPEN_DIR/tools/osx/Enabler-Info.plist',
      'cat $SOURCE |'
      'sed \'s/$${EXECUTABLE_NAME}/GearsEnabler/\' |'
      'sed \'s/$${PRODUCT_NAME}/GearsEnabler/\' > $TARGET')
  dirsrcs = [
      ('Contents/Info.plist', ['$BASE_OUTDIR/' + str(info[0])]),
      ('Contents/MacOS/', ['$SF_OUTDIR/GearsEnabler']),
      ('Contents/Resources/English.lproj/',
          ['$OPEN_DIR/tools/osx/English.lproj/InfoPlist.strings']),
  ]

  return env.DirBuilder('${SF_INPUTMANAGER_BUNDLE}', dirsrcs)
env.AddMethod(SafariInputManagerBundle)

installers = []
if 'FF3' in env['VALID_BROWSERS']:
  installers += env.FirefoxInstaller()
if 'SF' in env['VALID_BROWSERS']:
  installers += env.SafariInstallerPluginBundle()
  installers += env.SafariInstallerPackage()
  installers += env.SafariInputManagerBundle()
if env['OS'] == 'win32':
  installers += env.Win32Installer()
if env['OS'] == 'wince':
  installers += env.WinCEInstaller()

env.Alias('gears-installers', installers)
