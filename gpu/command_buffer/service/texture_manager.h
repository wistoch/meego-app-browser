// Copyright (c) 2010 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef GPU_COMMAND_BUFFER_SERVICE_TEXTURE_MANAGER_H_
#define GPU_COMMAND_BUFFER_SERVICE_TEXTURE_MANAGER_H_

#include <map>
#include <vector>
#include "base/basictypes.h"
#include "base/linked_ptr.h"
#include "gpu/command_buffer/service/gl_utils.h"

namespace gpu {
namespace gles2 {

// This class keeps track of the textures and their sizes so we can do NPOT and
// texture complete checking.
//
// NOTE: To support shared resources an instance of this class will need to be
// shared by multiple GLES2Decoders.
class TextureManager {
 public:
  // Info about Textures currently in the system.
  class TextureInfo {
   public:
    explicit TextureInfo(GLuint texture)
        : texture_(texture),
          target_(0),
          max_level_set_(-1),
          texture_complete_(false),
          cube_complete_(false),
          npot_(false) {
    }

    // Returns the target this texure was first bound to or 0 if it has not
    // been bound. Once a texture is bound to a specific target it can never be
    // bound to a different target.
    GLenum target() {
      return target_;
    }

    void SetTarget(GLenum target, GLint max_levels) {
      DCHECK_EQ(0u, target_);  // you can only set this once.
      target_ = target;
      size_t num_faces = (target == GL_TEXTURE_2D) ? 1 : 6;
      level_infos_.resize(num_faces);
      for (size_t ii = 0; ii < num_faces; ++ii) {
        level_infos_[ii].resize(max_levels);
      }
    }

    // In GLES2 "texture complete" means it has all required mips for filtering
    // down to a 1x1 pixel texture, they are in the correct order, they are all
    // the same format.
    bool texture_complete() const {
      return texture_complete_;
    }

    // Whether or not this texture is a non-power-of-two texture.
    bool npot() const {
      return npot_;
    }

    // Returns true if mipmaps can be generated by GL.
    bool CanGenerateMipmaps() const;

    // Makes each of the mip levels as though they were generated.
    void MarkMipmapsGenerated();

    // Set the info for a particular level.
    void SetLevelInfo(
        GLenum target,
        GLint level,
        GLint internal_format,
        GLsizei width,
        GLsizei height,
        GLsizei depth,
        GLint border,
        GLenum format,
        GLenum type);

   protected:
    struct LevelInfo {
      LevelInfo()
         : valid(false),
           internal_format(0),
           width(0),
           height(0),
           depth(0),
           border(0),
           format(0),
           type(0) {
      }

      bool valid;
      GLint internal_format;
      GLsizei width;
      GLsizei height;
      GLsizei depth;
      GLint border;
      GLenum format;
      GLenum type;
    };

   private:
    // Update info about this texture.
    void Update();

    // Info about each face and level of texture.
    std::vector<std::vector<LevelInfo> > level_infos_;

    // The id of the texure
    GLuint texture_;

    // The target. 0 if unset, otherwise GL_TEXTURE_2D or GL_TEXTURE_CUBE_MAP.
    GLenum target_;

    // The maximum level that has been set.
    GLint max_level_set_;

    // Whether or not this texture is "texture complete"
    bool texture_complete_;

    // Whether or not this texture is "cube complete"
    bool cube_complete_;

    // Whether or not this texture is non-power-of-two
    bool npot_;

    DISALLOW_COPY_AND_ASSIGN(TextureInfo);
  };

  TextureManager(GLsizei max_texture_size, GLsizei max_cube_map_texture_size);

  // Returns the maximum number of levels.
  GLint MaxLevelsForTarget(GLenum target) const {
    return (target == GL_TEXTURE_2D) ? max_levels_ : max_cube_map_levels_;
  }

  // Returns the maximum size.
  GLsizei MaxSizeForTarget(GLenum target) const {
    return (target == GL_TEXTURE_2D) ? max_texture_size_ :
                                       max_cube_map_texture_size_;
  }

  // Checks if a dimensions are valid for a given target.
  bool ValidForTarget(
      GLenum target, GLint level,
      GLsizei width, GLsizei height, GLsizei depth) {
    GLsizei max_size = MaxSizeForTarget(target);
    return level >= 0 &&
           width >= 0 &&
           height >= 0 &&
           depth >= 0 &&
           level < MaxLevelsForTarget(target) &&
           width <= max_size &&
           height <= max_size &&
           depth <= max_size;
  }

  // Creates a new texture info.
  void CreateTextureInfo(GLuint texture);

  // Gets the texture info for the given texture.
  TextureInfo* GetTextureInfo(GLuint texture);

  // Removes a texture info.
  void RemoveTextureInfo(GLuint texture_id);

 private:
  // Info for each texture in the system.
  // TODO(gman): Choose a faster container.
  typedef std::map<GLuint, linked_ptr<TextureInfo> > TextureInfoMap;
  TextureInfoMap texture_infos_;

  GLsizei max_texture_size_;
  GLsizei max_cube_map_texture_size_;
  GLint max_levels_;
  GLint max_cube_map_levels_;

  DISALLOW_COPY_AND_ASSIGN(TextureManager);
};

}  // namespace gles2
}  // namespace gpu

#endif  // GPU_COMMAND_BUFFER_SERVICE_TEXTURE_MANAGER_H_

