// Copyright (c) 2011 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef MEDIA_VIDEO_VIDEO_DECODE_ACCELERATOR_H_
#define MEDIA_VIDEO_VIDEO_DECODE_ACCELERATOR_H_

#include <vector>

#include "base/basictypes.h"
#include "base/callback.h"
#include "media/base/bitstream_buffer.h"
#include "ui/gfx/size.h"

namespace media {

typedef Callback0::Type VideoDecodeAcceleratorCallback;

// Video decoder interface.
class VideoDecodeAccelerator {
 public:
  virtual ~VideoDecodeAccelerator() {}

  // Enumeration of potential errors generated by the API.
  enum Error {
    VIDEODECODERERROR_NONE = 0,
    VIDEODECODERERROR_UNINITIALIZED,
    VIDEODECODERERROR_UNSUPPORTED,
    VIDEODECODERERROR_INSUFFICIENT_BUFFERS,
    VIDEODECODERERROR_INSUFFICIENT_RESOURCES,
    VIDEODECODERERROR_HARDWARE,
  };

  // Interface expected from PictureBuffers where pictures are stored.
  class PictureBuffer {
   public:
    enum MemoryType {
      PICTUREBUFFER_MEMORYTYPE_SYSTEM = 0,
      PICTUREBUFFER_MEMORYTYPE_GL_TEXTURE,
    };

    virtual ~PictureBuffer();
    virtual uint32 GetId() = 0;
    virtual gfx::Size GetSize() = 0;
    virtual const std::vector<uint32>& GetColorFormat() = 0;
    virtual MemoryType GetMemoryType() = 0;
  };

  class Picture {
   public:
    virtual ~Picture();

    // Picture size related functions.
    // There are three types of logical picture sizes that applications using
    // video decoder should be aware of:
    //   - Visible picture size,
    //   - Decoded picture size, and
    //   - Picture buffer size.
    //
    // Visible picture size means the actual picture size that is intended to be
    // displayed from the decoded output.
    //
    // Decoded picture size might vary from the visible size of the picture,
    // because of the underlying properties of the codec. Vast majority of
    // modern video compression algorithms are based on (macro)block-based
    // transforms and therefore process the picture in small windows (usually
    // of size 16x16 pixels) one by one. However, if the native picture size
    // does not happen to match the block-size of the algorithm, there may be
    // redundant data left on the sides of the output picture, which are not
    // intended for display. For example, this happens to video of size 854x480
    // and H.264 codec. Since the width (854 pixels) is not multiple of the
    // block size of the coding format (16 pixels), pixel columns 854-863
    // contain garbage data which is notintended for display.
    //
    // Plugin is providing the buffers for output decoding and it should know
    // the picture buffer size it has provided to the decoder. Thus, there is
    // no function to query the buffer size from this class.

    // Returns the decoded size of the decoded picture in pixels.
    virtual gfx::Size GetDecodedSize() const = 0;

    // Returns the visible size of the decoded picture in pixels.
    virtual gfx::Size GetVisibleSize() const = 0;

    // Returns metadata associated with the picture.
    virtual void* GetUserHandle() = 0;
  };

  // Interface for collaborating with picture interface to provide memory for
  // output picture and blitting them.
  class Client {
   public:
    virtual ~Client() {}

    // Callback to tell the information needed by the client to provide decoding
    // buffer to the decoder.
    virtual void ProvidePictureBuffers(
        uint32 requested_num_of_buffers,
        const std::vector<uint32>& buffer_properties) = 0;

    // Callback to dismiss picture buffer that was assigned earlier.
    virtual void DismissPictureBuffer(PictureBuffer* picture_buffer) = 0;

    // Callback to deliver decoded pictures ready to be displayed.
    virtual void PictureReady(Picture* picture) = 0;

    // Callback to notify that decoder has decoded end of stream marker and has
    // outputted all displayable pictures.
    virtual void NotifyEndOfStream() = 0;

    // Callback to notify about decoding errors.
    virtual void NotifyError(Error error) = 0;
  };

  // Video decoder functions.
  // GetConfig returns supported configurations that are subsets of given
  // |prototype_config|.
  // Parameters:
  //  |instance| is the pointer to the plug-in instance.
  //  |prototype_config| is the prototypical configuration.
  //
  // Returns std::vector containing all the configurations that match the
  // prototypical configuration.
  virtual const std::vector<uint32>& GetConfig(
      const std::vector<uint32>& prototype_config) = 0;

  // Initializes the video decoder with specific configuration.
  // Parameters:
  //  |config| is the configuration on which the decoder should be initialized.
  //
  // Returns true when command successfully accepted. Otherwise false.
  virtual bool Initialize(const std::vector<uint32>& config) = 0;

  // Decodes given bitstream buffer. Once decoder is done with processing
  // |bitstream_buffer| is will call |callback|.
  // Parameters:
  //  |bitstream_buffer| is the input bitstream that is sent for decoding.
  //  |callback| contains the callback function pointer for informing about
  //  finished processing for |bitstream_buffer|.
  //
  // Returns true when command successfully accepted. Otherwise false.
  virtual bool Decode(BitstreamBuffer* bitstream_buffer,
                      VideoDecodeAcceleratorCallback* callback) = 0;

  // Assigns picture buffer to the video decoder. This function must be called
  // at latest when decoder has made a ProvidePictureBuffers callback to the
  // client. Ownership of the picture buffer remains with the client, but it is
  // not allowed to deallocate picture buffer before DismissPictureBuffer
  // callback has been initiated for a given buffer.
  //
  // Parameters:
  //  |picture_buffers| contains the allocated picture buffers for the output.
  virtual void AssignPictureBuffer(
      std::vector<PictureBuffer*> picture_buffers) = 0;

  // Sends picture buffers to be reused by the decoder. This needs to be called
  // for each buffer that has been processed so that decoder may know onto which
  // picture buffers it can write the output to.
  //
  // Parameters:
  //  |picture_buffer| points to the picture buffer that is to be reused.
  virtual void ReusePictureBuffer(PictureBuffer* picture_buffer) = 0;

  // Flushes the decoder. Flushing will result in output of the
  // pictures and buffers held inside the decoder and returning of bitstream
  // buffers using the callbacks implemented by the plug-in. Once done with
  // flushing, the decode will call the |callback|.
  //
  // Parameters:
  //  |callback| contains the callback function pointer.
  //
  // Returns true when command successfully accepted. Otherwise false.
  virtual bool Flush(VideoDecodeAcceleratorCallback* callback) = 0;

  // Aborts the decoder. Decode will abort the decoding as soon as possible and
  // will not output anything. |callback| will be called as soon as abort has
  // been finished. After abort all buffers can be considered dismissed, even
  // when there has not been callbacks to dismiss them.
  //
  // Parameters:
  //  |callback| contains the callback function pointer.
  //
  // Returns true when command successfully accepted. Otherwise false.
   virtual bool Abort(VideoDecodeAcceleratorCallback* callback) = 0;
};

}  // namespace media

#endif  // MEDIA_VIDEO_VIDEO_DECODE_ACCELERATOR_H_
