--- ParseFTPList.cpp.orig	2009-09-23 09:32:45.000000000 +0200
+++ ParseFTPList.cpp	2009-11-28 20:34:21.000000000 +0100
@@ -36,16 +36,19 @@
  *
  * ***** END LICENSE BLOCK ***** */
 
-#include <stdlib.h>
-#include <string.h>
+#include "net/third_party/parseftp/ParseFTPList.h"
+
 #include <ctype.h>
-#include "plstr.h"
-#include "nsDebug.h"
 
-#include "ParseFTPList.h"
+#include "base/logging.h"
+#include "base/string_util.h"
+
+using base::Time;
 
 /* ==================================================================== */
 
+namespace net {
+
 static inline int ParsingFailed(struct list_state *state)
 {
   if (state->parsed_one || state->lstyle) /* junk if we fail to parse */
@@ -167,11 +170,10 @@
                 pos++;
               if (pos < linelen && line[pos] == ',')
               {
-                PRTime t;
-                PRTime seconds;
-                PR_sscanf(p+1, "%llu", &seconds);
-                LL_MUL(t, seconds, PR_USEC_PER_SEC);
-                PR_ExplodeTime(t, PR_LocalTimeParameters, &(result->fe_time) );
+                uint64 seconds = StringToInt64(p+1);
+                Time t = Time::FromTimeT(seconds);
+                t.LocalExplode(&(result->fe_time));
+                result->fe_time.month--;
               }
             }
           }
@@ -370,7 +372,7 @@
             if (lstyle && pos < (toklen[0]-1))
             {
               /* ']' was found and there is at least one character after it */
-              NS_ASSERTION(*p == ']', "unexpected state");
+              DCHECK(*p == ']') << "unexpected state";
               pos++;
               p++;
               tokmarker = pos; /* length of leading "[DIR1.DIR2.etc]" */
@@ -524,12 +526,9 @@
                * So its rounded up to the next block, so what, its better
                * than not showing the size at all.
               */
-              PRUint64 fsz, factor;
-              LL_UI2L(fsz, strtoul(tokens[1], (char **)0, 10));
-              LL_UI2L(factor, 512);
-              LL_MUL(fsz, fsz, factor);
-              PR_snprintf(result->fe_size, sizeof(result->fe_size), 
-                          "%lld", fsz);
+              long long size = strtoul(tokens[1], NULL, 10) * 512;
+              base::snprintf(result->fe_size, sizeof(result->fe_size), "%lld",
+                             size);
             } 
 
           } /* if (result->fe_type != 'd') */
@@ -551,17 +550,17 @@
           }
           if (month_num >= 12)
             month_num = 0;
-          result->fe_time.tm_month = month_num;
-          result->fe_time.tm_mday = atoi(tokens[2]);
-          result->fe_time.tm_year = atoi(p+4); // NSPR wants year as XXXX
+          result->fe_time.month = month_num;
+          result->fe_time.day_of_month = atoi(tokens[2]);
+          result->fe_time.year = atoi(p+4);
 
           p = tokens[3] + 2;
           if (*p == ':')
             p++;
           if (p[2] == ':')
-            result->fe_time.tm_sec = atoi(p+3);
-          result->fe_time.tm_hour = atoi(tokens[3]);
-          result->fe_time.tm_min  = atoi(p);
+            result->fe_time.second = atoi(p+3);
+          result->fe_time.hour = atoi(tokens[3]);
+          result->fe_time.minute  = atoi(p);
       
           return result->fe_type;
 
@@ -694,25 +693,25 @@
         p = tokens[tokmarker+4];
         if (toklen[tokmarker+4] == 10) /* newstyle: YYYY-MM-DD format */
         {
-          result->fe_time.tm_year = atoi(p+0) - 1900;
-          result->fe_time.tm_month  = atoi(p+5) - 1;
-          result->fe_time.tm_mday = atoi(p+8);
+          result->fe_time.year = atoi(p+0) - 1900;
+          result->fe_time.month  = atoi(p+5) - 1;
+          result->fe_time.day_of_month = atoi(p+8);
         }
         else /* oldstyle: [M]M/DD/YY format */
         {
           pos = toklen[tokmarker+4];
-          result->fe_time.tm_month  = atoi(p) - 1;
-          result->fe_time.tm_mday = atoi((p+pos)-5);
-          result->fe_time.tm_year = atoi((p+pos)-2);
-          if (result->fe_time.tm_year < 70)
-            result->fe_time.tm_year += 100;
+          result->fe_time.month  = atoi(p) - 1;
+          result->fe_time.day_of_month = atoi((p+pos)-5);
+          result->fe_time.year = atoi((p+pos)-2);
+          if (result->fe_time.year < 70)
+            result->fe_time.year += 100;
         }
 
         p = tokens[tokmarker+5];
         pos = toklen[tokmarker+5];
-        result->fe_time.tm_hour  = atoi(p);
-        result->fe_time.tm_min = atoi((p+pos)-5);
-        result->fe_time.tm_sec = atoi((p+pos)-2);
+        result->fe_time.hour  = atoi(p);
+        result->fe_time.minute = atoi((p+pos)-5);
+        result->fe_time.second = atoi((p+pos)-2);
 
         result->fe_cinfs = 1;
         result->fe_fname = tokens[0];
@@ -855,25 +854,25 @@
           }
         }
 
-        result->fe_time.tm_month = atoi(tokens[0]+0);
-        if (result->fe_time.tm_month != 0)
+        result->fe_time.month = atoi(tokens[0]+0);
+        if (result->fe_time.month != 0)
         {
-          result->fe_time.tm_month--;
-          result->fe_time.tm_mday = atoi(tokens[0]+3);
-          result->fe_time.tm_year = atoi(tokens[0]+6);
+          result->fe_time.month--;
+          result->fe_time.day_of_month = atoi(tokens[0]+3);
+          result->fe_time.year = atoi(tokens[0]+6);
           /* if year has only two digits then assume that
                00-79 is 2000-2079
                80-99 is 1980-1999 */
-          if (result->fe_time.tm_year < 80)
-            result->fe_time.tm_year += 2000;
-          else if (result->fe_time.tm_year < 100)
-            result->fe_time.tm_year += 1900;
+          if (result->fe_time.year < 80)
+            result->fe_time.year += 2000;
+          else if (result->fe_time.year < 100)
+            result->fe_time.year += 1900;
         }
 
-        result->fe_time.tm_hour = atoi(tokens[1]+0);
-        result->fe_time.tm_min = atoi(tokens[1]+3);
-        if ((tokens[1][5]) == 'P' && result->fe_time.tm_hour < 12)
-          result->fe_time.tm_hour += 12;
+        result->fe_time.hour = atoi(tokens[1]+0);
+        result->fe_time.minute = atoi(tokens[1]+3);
+        if ((tokens[1][5]) == 'P' && result->fe_time.hour < 12)
+          result->fe_time.hour += 12;
 
         /* the caller should do this (if dropping "." and ".." is desired)
         if (result->fe_type == 'd' && result->fe_fname[0] == '.' &&
@@ -971,13 +970,13 @@
           result->fe_size[pos] = '\0';
         }  
     
-        result->fe_time.tm_month = atoi(&p[35-18]) - 1;
-        result->fe_time.tm_mday = atoi(&p[38-18]);
-        result->fe_time.tm_year = atoi(&p[41-18]);
-        if (result->fe_time.tm_year < 80)
-          result->fe_time.tm_year += 100;
-        result->fe_time.tm_hour = atoi(&p[46-18]);
-        result->fe_time.tm_min = atoi(&p[49-18]);
+        result->fe_time.month = atoi(&p[35-18]) - 1;
+        result->fe_time.day_of_month = atoi(&p[38-18]);
+        result->fe_time.year = atoi(&p[41-18]);
+        if (result->fe_time.year < 80)
+          result->fe_time.year += 100;
+        result->fe_time.hour = atoi(&p[46-18]);
+        result->fe_time.minute = atoi(&p[49-18]);
    
         /* the caller should do this (if dropping "." and ".." is desired)
         if (result->fe_type == 'd' && result->fe_fname[0] == '.' &&
@@ -1022,7 +1021,7 @@
        * "drwxr-xr-x  2 0  0  512 May 28 22:17 etc"
       */
     
-      PRBool is_old_Hellsoft = PR_FALSE;
+      bool is_old_Hellsoft = false;
     
       if (numtoks >= 6)
       {
@@ -1050,7 +1049,7 @@
               /* rest is FMA[S] or AFM[S] */
               lstyle = 'U'; /* very likely one of the NetWare servers */
               if (toklen[0] == 10)
-                is_old_Hellsoft = PR_TRUE;
+                is_old_Hellsoft = true;
             }
           }
         }
@@ -1166,10 +1165,10 @@
           result->fe_size[pos] = '\0';
         }
 
-        result->fe_time.tm_month  = month_num;
-        result->fe_time.tm_mday = atoi(tokens[tokmarker+2]);
-        if (result->fe_time.tm_mday == 0)
-          result->fe_time.tm_mday++;
+        result->fe_time.month  = month_num;
+        result->fe_time.day_of_month = atoi(tokens[tokmarker+2]);
+        if (result->fe_time.day_of_month == 0)
+          result->fe_time.day_of_month++;
 
         p = tokens[tokmarker+3];
         pos = (unsigned int)atoi(p);
@@ -1177,25 +1176,27 @@
           p--;
         if (p[2] != ':') /* year */
         {
-          result->fe_time.tm_year = pos;
+          result->fe_time.year = pos;
         }
         else
         {
-          result->fe_time.tm_hour = pos;
-          result->fe_time.tm_min  = atoi(p+3);
+          result->fe_time.hour = pos;
+          result->fe_time.minute  = atoi(p+3);
           if (p[5] == ':')
-            result->fe_time.tm_sec = atoi(p+6);
+            result->fe_time.second = atoi(p+6);
        
-          if (!state->now_time)
+          if (!state->now_tm_valid)
           {
-            state->now_time = PR_Now();
-            PR_ExplodeTime((state->now_time), PR_LocalTimeParameters, &(state->now_tm) );
+            Time t = Time::Now();
+            t.LocalExplode(&(state->now_tm));
+            state->now_tm.month--;
+            state->now_tm_valid = true;
           }
 
-          result->fe_time.tm_year = state->now_tm.tm_year;
-          if ( (( state->now_tm.tm_month << 5) + state->now_tm.tm_mday) <
-               ((result->fe_time.tm_month << 5) + result->fe_time.tm_mday) )
-            result->fe_time.tm_year--;
+          result->fe_time.year = state->now_tm.year;
+          if ( (( state->now_tm.month << 5) + state->now_tm.day_of_month) <
+               ((result->fe_time.month << 5) + result->fe_time.day_of_month) )
+            result->fe_time.year--;
        
         } /* time/year */
         
@@ -1213,10 +1214,10 @@
         {
           /* First try to use result->fe_size to find " -> " sequence.
              This can give proper result for cases like "aaa -> bbb -> ccc". */
-          PRUint32 fe_size = atoi(result->fe_size);
+          unsigned int fe_size = atoi(result->fe_size);
 
           if (result->fe_fnlen > (fe_size + 4) &&
-              PL_strncmp(result->fe_fname + result->fe_fnlen - fe_size - 4 , " -> ", 4) == 0)
+              strncmp(result->fe_fname + result->fe_fnlen - fe_size - 4 , " -> ", 4) == 0)
           {
             result->fe_lname = result->fe_fname + (result->fe_fnlen - fe_size);
             result->fe_lnlen = (&(line[linelen])) - (result->fe_lname);
@@ -1232,7 +1233,7 @@
             p = result->fe_fname + (result->fe_fnlen - 5);
             for (pos = (result->fe_fnlen - 5); pos > 0; pos--)
             {
-              if (PL_strncmp(p, " -> ", 4) == 0)
+              if (strncmp(p, " -> ", 4) == 0)
               {
                 result->fe_lname = p + 4;
                 result->fe_lnlen = (&(line[linelen]))
@@ -1387,9 +1388,9 @@
                 tbuf[1] == month_names[pos+1] && 
                 tbuf[2] == month_names[pos+2])
             {
-              result->fe_time.tm_month = pos/3;
-              result->fe_time.tm_mday = atoi(tokens[3]);
-              result->fe_time.tm_year = atoi(tokens[4]) - 1900;
+              result->fe_time.month = pos/3;
+              result->fe_time.day_of_month = atoi(tokens[3]);
+              result->fe_time.year = atoi(tokens[4]) - 1900;
               break;
             }
           }          
@@ -1397,17 +1398,17 @@
         }
         else
         {
-          result->fe_time.tm_month = atoi(p+0)-1;
-          result->fe_time.tm_mday = atoi(p+3);
-          result->fe_time.tm_year = atoi(p+6);
-          if (result->fe_time.tm_year < 80) /* SuperTCP */
-            result->fe_time.tm_year += 100;
+          result->fe_time.month = atoi(p+0)-1;
+          result->fe_time.day_of_month = atoi(p+3);
+          result->fe_time.year = atoi(p+6);
+          if (result->fe_time.year < 80) /* SuperTCP */
+            result->fe_time.year += 100;
 
           pos = 3; /* SuperTCP toknum of date field */
         }
 
-        result->fe_time.tm_hour = atoi(tokens[pos]);
-        result->fe_time.tm_min = atoi(&(tokens[pos][toklen[pos]-2]));
+        result->fe_time.hour = atoi(tokens[pos]);
+        result->fe_time.minute = atoi(&(tokens[pos][toklen[pos]-2]));
 
         /* the caller should do this (if dropping "." and ".." is desired)
         if (result->fe_type == 'd' && result->fe_fname[0] == '.' &&
@@ -1623,7 +1624,7 @@
               pos = atoi(tokens[pos]);
               if (pos > 0 && pos <= 31)
               {
-                result->fe_time.tm_mday = pos;
+                result->fe_time.day_of_month = pos;
                 month_num = 1;
                 for (pos = 0; pos < (12*3); pos+=3)
                 {
@@ -1634,34 +1635,36 @@
                   month_num++;
                 }
                 if (month_num > 12)
-                  result->fe_time.tm_mday = 0;
+                  result->fe_time.day_of_month = 0;
                 else
-                  result->fe_time.tm_month = month_num - 1;
+                  result->fe_time.month = month_num - 1;
               }
             }
-            if (result->fe_time.tm_mday)
+            if (result->fe_time.day_of_month)
             {
               tokmarker += 3; /* skip mday/mon/yrtime (to find " -> ") */
               p = tokens[tokmarker];
 
               pos = atoi(p);
               if (pos > 24)
-                result->fe_time.tm_year = pos-1900;
+                result->fe_time.year = pos-1900;
               else
               {
                 if (p[1] == ':')
                   p--;
-                result->fe_time.tm_hour = pos;
-                result->fe_time.tm_min = atoi(p+3);
-                if (!state->now_time)
-                {
-                  state->now_time = PR_Now();
-                  PR_ExplodeTime((state->now_time), PR_LocalTimeParameters, &(state->now_tm) );
-                }
-                result->fe_time.tm_year = state->now_tm.tm_year;
-                if ( (( state->now_tm.tm_month  << 4) + state->now_tm.tm_mday) <
-                     ((result->fe_time.tm_month << 4) + result->fe_time.tm_mday) )
-                  result->fe_time.tm_year--;
+                result->fe_time.hour = pos;
+                result->fe_time.minute = atoi(p+3);
+                if (!state->now_tm_valid)
+                {
+                  Time t = Time::Now();
+                  t.LocalExplode(&(state->now_tm));
+                  state->now_tm.month--;
+                  state->now_tm_valid = true;
+                }
+                result->fe_time.year = state->now_tm.year;
+                if ( (( state->now_tm.month  << 4) + state->now_tm.day_of_month) <
+                     ((result->fe_time.month << 4) + result->fe_time.day_of_month) )
+                  result->fe_time.year--;
               } /* got year or time */
             } /* got month/mday */
           } /* may have year or time */
@@ -1907,3 +1910,5 @@
   return 0;
 }
 #endif
+
+}  // namespace net
--- ParseFTPList.h.orig	2008-12-15 21:10:49.000000000 +0100
+++ ParseFTPList.h	2009-09-27 00:53:54.000000000 +0200
@@ -35,7 +35,11 @@
  * the terms of any one of the MPL, the GPL or the LGPL.
  *
  * ***** END LICENSE BLOCK ***** */
-#include "nspr.h"
+
+#ifndef NET_THIRD_PARTY_PARSEFTP_PARSEFTPLIST_H_
+#define NET_THIRD_PARTY_PARSEFTP_PARSEFTPLIST_H_
+
+#include "base/time.h"
 
 /* ParseFTPList() parses lines from an FTP LIST command.
 **
@@ -96,28 +100,35 @@
 #define SUPPORT_OS2  /* IBM TCP/IP for OS/2 - FTP Server */
 #define SUPPORT_W16  /* win16 hosts: SuperTCP or NetManage Chameleon */
 
+namespace net {
+
+/* WARNING: The 'month' field of base::Time::Exploded will be in range 0-11
+ * (0 = January) to match PRExplodedTime. The caller should add 1 to 'month'
+ * if it intends to use it.
+ */
+
 struct list_state
 {
   void           *magic;        /* to determine if previously initialized */
-  PRTime         now_time;      /* needed for year determination */
-  PRExplodedTime now_tm;        /* needed for year determination */
-  PRInt32        lstyle;        /* LISTing style */
-  PRInt32        parsed_one;    /* returned anything yet? */
+  bool           now_tm_valid;  /* true if now_tm is valid */
+  base::Time::Exploded now_tm;  /* needed for year determination */
+  int            lstyle;        /* LISTing style */
+  int            parsed_one;    /* returned anything yet? */
   char           carry_buf[84]; /* for VMS multiline */
-  PRUint32       carry_buf_len; /* length of name in carry_buf */
-  PRUint32       numlines;      /* number of lines seen */
+  unsigned int   carry_buf_len; /* length of name in carry_buf */
+  unsigned int   numlines;      /* number of lines seen */
 };
 
 struct list_result
 {
-  PRInt32           fe_type;      /* 'd'(dir) or 'l'(link) or 'f'(file) */
+  int               fe_type;      /* 'd'(dir) or 'l'(link) or 'f'(file) */
   const char *      fe_fname;     /* pointer to filename */
-  PRUint32          fe_fnlen;     /* length of filename */
+  unsigned int      fe_fnlen;     /* length of filename */
   const char *      fe_lname;     /* pointer to symlink name */
-  PRUint32          fe_lnlen;     /* length of symlink name */
+  unsigned int      fe_lnlen;     /* length of symlink name */
   char              fe_size[40];  /* size of file in bytes (<= (2^128 - 1)) */
-  PRExplodedTime    fe_time;      /* last-modified time */
-  PRInt32           fe_cinfs;     /* file system is definitely case insensitive */
+  base::Time::Exploded fe_time;   /* last-modified time */
+  int               fe_cinfs;     /* file system is definitely case insensitive */
                                   /* (converting all-upcase names may be desirable) */
 };
 
@@ -125,3 +136,6 @@
                  struct list_state *state,
                  struct list_result *result );
 
+}  // namespace net
+
+#endif  // NET_THIRD_PARTY_PARSEFTP_PARSEFTPLIST_H_
