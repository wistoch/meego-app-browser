# Copyright 2009, Google Inc.
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are
# met:
#
#     * Redistributions of source code must retain the above copyright
# notice, this list of conditions and the following disclaimer.
#     * Redistributions in binary form must reproduce the above
# copyright notice, this list of conditions and the following disclaimer
# in the documentation and/or other materials provided with the
# distribution.
#     * Neither the name of Google Inc. nor the names of its
# contributors may be used to endorse or promote products derived from
# this software without specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
# A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
# OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
# LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
# DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
# THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

import os
import subprocess
import SCons

Import('env')

# Check if Debian packaging tools are installed. If so, make a .deb package.
if subprocess.Popen(["which", "dpkg-buildpackage"],
    stdout=open(os.devnull, "w")).wait() == 0:

  print('Found dpkg-buildpackage in PATH; will create Debian packages.');

  current_source_dir = os.path.join(env['SCONSTRUCT_DIR'], 'installer/linux')

  def OutputFromShellCommand(command):
    process = subprocess.Popen(command, shell=True, stdout=subprocess.PIPE)
    return process.communicate()[0].strip()

  def _InternalBuildDebianPackage(env, src_dir, obj_dir, debian_files,
      package_files, output_dir=None, force_version=None):
    """Creates build rules to build a Debian package from the specified sources.

    Args:
      env: SCons Environment.
      src_dir: Current source path, to which the debian_files are
          relative.
      obj_dir: Directory to place object files in.
      debian_files: Array of the Debian control file sources that should be
          copied into the package source tree, e.g., changelog, control, rules,
          etc. Must be relative to current source dir.
      package_files: An array of 2-tuples listing the files that should be
          copied into the package source tree.
          The first element is the path where the file should be placed for the
              .install control file to find it, relative to the generated debian
              package source directory.
          The second element is the file source.
      output_dir: An optional directory to place the files in. If omitted, the
          current output directory is used.
      force_version: Optional. Forces the version of the package to start with
          this version string if specified. If the last entry in the changelog
          is not for a version that starts with this then a dummy entry is
          generated with this version and a ~prerelease suffix (so that the
          final version will compare as greater).

    Return:
      A list of the targets (at least two).
    """
    # Read the control file and changelog file to determine the package name,
    # version, and arch that the Debian build tools will use to name the
    # generated files.
    control_file = None
    changelog_file = None
    for file in debian_files:
      if os.path.basename(file) == "control":
        control_file = os.path.join(src_dir, file)
      elif os.path.basename(file) == "changelog":
        changelog_file = os.path.join(src_dir, file)
    if control_file == None:
      raise Exception("Need to have a control file")
    if changelog_file == None:
      raise Exception("Need to have a changelog file")
    source = OutputFromShellCommand(
        "awk '/^Source:/ { print $2; }' " + control_file)
    packages = OutputFromShellCommand(
        "awk '/^Package:/ { print $2; }' " + control_file).split("\n")
    version = OutputFromShellCommand(
        "sed -nr '1 { s/.*\\((.*)\\).*/\\1/; p }' " + changelog_file)
    arch = OutputFromShellCommand(
        "awk '/^Architecture:/ { print $2; }' %s | head -n 1" % control_file)
    add_dummy_changelog_entry = False
    if force_version != None and not version.startswith(force_version):
      print('Warning: no entry in ' + changelog_file + ' for version ' +
          force_version + ' (last is ' + version +'). A dummy entry will be ' +
          'generated. Remember to add the real changelog entry before ' +
          'releasing.');
      version = force_version + '~prerelease'
      add_dummy_changelog_entry = True
    source_dir_name = source + "_" + version + "_" + arch
    target_file_names = [ source_dir_name + ".changes" ]
    for package in packages:
      package_file_name = package + "_" + version + "_" + arch + ".deb"
      target_file_names.append(package_file_name)
    # The targets
    if output_dir != None:
      targets = [os.path.join(output_dir, s) for s in target_file_names]
    else:
      targets = target_file_names
    # Path to where we will construct the debian build tree.
    deb_build_tree = os.path.join(obj_dir, source_dir_name, "deb_build_tree")
    # First copy the files.
    for file in package_files:
      env.Command(os.path.join(deb_build_tree, file[0]), file[1],
          SCons.Defaults.Copy('$TARGET', '$SOURCE'))
      env.Depends(targets, os.path.join(deb_build_tree, file[0]))
    # Now copy the Debian metadata sources. We have to do this all at once so
    # that we can remove the target directory before copying, because there
    # can't be any other stale files there or else dpkg-buildpackage may use
    # them and give incorrect build output.
    copied_debian_files_paths = []
    for file in debian_files:
      copied_debian_files_paths.append(os.path.join(deb_build_tree, "debian",
          os.path.basename(file)))
    copy_commands = [
        """dir=$$(dirname $TARGET) && \
            rm -Rf $$dir && \
            mkdir -p $$dir && \
            cp $SOURCES $$dir && \
            chmod -R u+w $$dir"""
    ]
    if add_dummy_changelog_entry:
      copy_commands += [
          """debchange -c $$(dirname $TARGET)/changelog --newversion %s \
              --distribution UNRELEASED \
              'Developer preview build. (This entry was auto-generated.)'""" %
          version
      ]
    env.Command(copied_debian_files_paths, debian_files, copy_commands)
    env.Depends(targets, copied_debian_files_paths)
    # TODO(tschmelcher): Change this to sign the package for Google builds once
    # we start putting out Linux releases.
    # Must explicitly specify -a because otherwise cross-builds won't work.
    # Must explicitly specify -D because -a disables it.
    # Must explicitly specify fakeroot because old dpkg tools don't assume that.
    env.Command(targets, None,
        """dir=%(dir)s && \
            cd $$dir && \
            dpkg-buildpackage -b -uc -a%(arch)s -D -rfakeroot && \
            cd $$OLDPWD && \
            for file in %(targets)s; do \
              mv $$dir/../$$file $$(dirname $TARGET); \
            done""" %
        {'dir':env.Dir(deb_build_tree).path,
         'arch':arch,
         'targets':" ".join(target_file_names)})
    return targets

  def BuildDebianPackage(debian_files, package_files, output_dir=None,
      force_version=None):
    return _InternalBuildDebianPackage(env, current_source_dir, ".",
        debian_files, package_files, output_dir, force_version)

  # Build amd64 package.
  BuildDebianPackage(["debian_common/changelog",
                      "debian_amd64/control",
                      "debian_amd64/google-o3d.install",
                      "debian_common/links",
                      "debian_amd64/postinst",
                      "debian_amd64/prerm",
                      "debian_amd64/rules"
                     ],
                     [("libnpo3dautoplugin.so",
                           '$ARTIFACTS_DIR/libnpo3dautoplugin.so'),
                      ("libGLEW.so.1.5", '$ARTIFACTS_DIR/libGLEW.so.1.5'),
                      ("libCg.so", '$ARTIFACTS_DIR/libCg.so'),
                      ("libCgGL.so", '$ARTIFACTS_DIR/libCgGL.so')
                     ],
                     output_dir='$ARTIFACTS_DIR',
                     force_version=env.get('O3D_PLUGIN_VERSION'))

  # Build i386 package.
  BuildDebianPackage(["debian_common/changelog",
                      "debian_i386/control",
                      "debian_i386/google-o3d.install",
                      "debian_common/links",
                      "debian_i386/rules"
                     ],
                     [("libnpo3dautoplugin.so",
                           '$ARTIFACTS_DIR/libnpo3dautoplugin.so'),
                      ("libCg.so", '$ARTIFACTS_DIR/libCg.so'),
                      ("libCgGL.so", '$ARTIFACTS_DIR/libCgGL.so')
                     ],
                     output_dir='$ARTIFACTS_DIR',
                     force_version=env.get('O3D_PLUGIN_VERSION'))

else:
  print('dpkg-buildpackage not found in PATH; Debian packages will not be '
      'built.');

# TODO(tschmelcher): Also build an RPM and a tgz.
