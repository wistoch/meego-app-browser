// Copyright (c) 2010 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.
//
// Protocol for communication between chromoting client and host.

syntax = "proto2";

option optimize_for = LITE_RUNTIME;

package remoting;

// A message that gets sent to the client after the client is connected to the
// host. It contains information that the client needs to know about the host.
// NEXT ID: 3
message InitClientMessage {
  required int32 width = 1;
  required int32 height = 2;
}

// A message to denote the beginning of an update stream. It will be followed
// by 0 or more UpdateStreamPacketMessages and then a EndUpdateStreamMessage.
// NEXT ID: 1
message BeginUpdateStreamMessage {
}

// A message to denote the end of an update stream.
// NEXT ID: 1
message EndUpdateStreamMessage {
}

// Identifies how the image was encoded.
enum UpdateStreamEncoding {
  EncodingInvalid = -1;
  EncodingNone = 0;
  EncodingZlib = 1;
}

// Identifies the pixel format.
// Note that this list should match exactly the same as
// media::VideoFrame::Format in media/base/video_frame.h.
enum PixelFormat {
  PixelFormatInvalid = 0;
  PixelFormatRgb555 = 1;
  PixelFormatRgb565 = 2;
  PixelFormatRgb24 = 3;
  PixelFormatRgb32 = 4;
  PixelFormatRgba = 5;
  PixelFormatYv12 = 6;
  PixelFormatYv16 = 7;
  PixelFormatNv12 = 8;
  PixelFormatEmpty = 9;
  PixelFormatAscii = 10;
}

// A message that denotes the beginning of an updating rectangle in an update
// stream packet.
// NEXT ID: 6
message UpdateStreamBeginRect {
  // X,Y coordinates (in screen pixels) for origin of this update.
  required int32 x = 1;
  required int32 y = 2;

  // Width, height (in screen pixels) for this update.
  required int32 width = 3;
  required int32 height = 4;

  // The encoding used for this image update.
  optional UpdateStreamEncoding encoding = 5 [default=EncodingNone];

  // The pixel format of this image.
  optional PixelFormat pixel_format = 6 [default=PixelFormatRgb24];
}

// A message that contains partial data for updating an rectangle in an
// update stream packet.
// NEXT ID: 3
message UpdateStreamRectData {
  // The sequence number of the partial data for updating a rectangle.
  optional int32 sequence_number = 1 [default=0];

  // The partial data for updating a rectangle.
  required bytes data = 2;
}

// A message that denotes the end of an updating rectangle.
// NEXT ID: 1
message UpdateStreamEndRect {
}

// A message to denote a partial update stream.
// NEXT ID: 4
message UpdateStreamPacketMessage {
  optional UpdateStreamBeginRect begin_rect = 1;
  optional UpdateStreamRectData rect_data = 2;
  optional UpdateStreamEndRect end_rect = 3;
}

// TODO(ajwong): Determine if these fields should be optional or required.
message RectangleFormat {
  // X,Y coordinates (in screen pixels) for origin of this update.
  required int32 x = 1;
  required int32 y = 2;

  // Width, height (in screen pixels) for this update.
  required int32 width = 3;
  required int32 height = 4;

  // The encoding used for this image update.
  optional UpdateStreamEncoding encoding = 5 [default = EncodingInvalid];

  // The pixel format of this image.
  optional PixelFormat pixel_format = 6 [default = PixelFormatRgb24];
}

message RectangleUpdatePacket {
  // Bitmasks for use in the flags field below.
  //
  // The encoder may fragment one update into multiple packets depending on
  // how the encoder outputs data.  Thus, one update can logically consist of
  // multiple packets.  The FIRST_PACKET and LAST_PACKET flags are used to
  // indicate the start and end of a logical update.  Here are notable
  // consequences:
  //  * Both FIRST_PACKET and LAST_PACKET may be set if an update is only
  //    one packet long.
  //  * The RectangleFormat is only supplied in a FIRST_PACKET.
  //  * An local update cannot change format between a FIRST_PACKET and
  //    a LAST_PACKET.
  //  * All packets in one logical update must be processed in order, and
  //    packets may not be skipped.
  enum Flags {
    FIRST_PACKET = 1;
    LAST_PACKET = 2;
  }
  optional int32 flags = 1 [default = 0];

  // The sequence number of the partial data for updating a rectangle.
  optional int32 sequence_number = 2 [default = 0];

  // This is provided on the first packet of the rectangle data, when
  // the flags has FIRST_PACKET set.
  optional RectangleFormat format = 3;

  optional bytes encoded_rect = 4;
}

// Defines the message that is sent from the host to the client.
// Only one of these messages should be present.
// NEXT ID: 5
message ChromotingHostMessage {
  optional InitClientMessage init_client= 1;
  optional BeginUpdateStreamMessage begin_update_stream = 2;
  optional EndUpdateStreamMessage end_update_stream = 3;
  optional UpdateStreamPacketMessage update_stream_packet = 4;

  optional RectangleUpdatePacket rectangle_update = 5;
}

// Defines a keyboard event.
// NEXT ID: 3
message KeyEvent {
  // The POSIX key code.
  required int32 key = 1;
  required bool pressed = 2;
}

// Sets the absolute position of the mouse cursor.
// dimension of the screen area.
// NEXT ID: 3
message MouseSetPositionEvent {
  required int32 x = 1;
  required int32 y = 2;

  // Windows sets absolute mouse pointer positions as a relative value to
  // the screen size. So pass the screen size to make this calculation easier.
  optional int32 width = 3;
  optional int32 height = 4;
}

// Adjust the position of the mouse cursor by an offset.
// NEXT ID: 3
message MouseMoveEvent {
  required int32 offset_x = 1;
  required int32 offset_y = 2;
}

// Motion of the mouse wheel.
// TODO(garykac): What are units here? How many units correspond to a single
// wheel click? On Windows, one click (WHEEL_DELTA) is 120 wheel units.
// NEXT ID: 3
message MouseWheelEvent {
  required int32 offset_x = 1;
  required int32 offset_y = 2;
}

enum MouseButton {
  MouseButtonUndefined = 0;
  MouseButtonLeft = 1;
  MouseButtonMiddle = 2;
  MouseButtonRight = 3;
}

// Mouse button is pressed down.
// NEXT ID: 2
message MouseDownEvent {
  required MouseButton button = 1;
}

// Mouse button is released.
// NEXT ID: 2
message MouseUpEvent {
  required MouseButton button = 1;
}

// Defines the message that is sent from the client to the host.
// Only one of the optional messages should be present.
// NEXT ID: 7
message ChromotingClientMessage {
  optional KeyEvent key_event = 1;
  optional MouseSetPositionEvent mouse_set_position_event = 2;
  optional MouseMoveEvent mouse_move_event = 3;
  optional MouseWheelEvent mouse_wheel_event = 4;
  optional MouseDownEvent mouse_down_event = 5;
  optional MouseUpEvent mouse_up_event = 6;
}
