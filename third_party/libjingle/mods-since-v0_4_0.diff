Only in libjingle/files: .svn
Only in libjingle-0.4.0/: Makefile.in
Only in libjingle-0.4.0/: aclocal.m4
Only in libjingle-0.4.0/: config.guess
diff -r --ignore-space-change --strip-trailing-cr libjingle-0.4.0/config.h libjingle/files/config.h
14c14
< #define HAVE_ALSA_ASOUNDLIB_H 1
---
> /* #undef HAVE_ALSA_ASOUNDLIB_H */
23c23
< #define HAVE_GLIB 1
---
> /* #undef HAVE_GLIB */
38c38
< #define HAVE_ORTP 1
---
> /* #undef HAVE_ORTP */
41c41
< #define HAVE_SPEEX 1
---
> /* #undef HAVE_SPEEX */
47c47
< #define HAVE_SPEEX_SPEEX_H 1
---
> /* #undef HAVE_SPEEX_SPEEX_H */
71c71
< #define LINUX 1
---
> /* #undef LINUX */
113c113
< #define __ALSA_ENABLED__ 1
---
> /* #undef __ALSA_ENABLED__ */
Only in libjingle-0.4.0/: config.h.in
Only in libjingle-0.4.0/: config.sub
Only in libjingle-0.4.0/: configure
Only in libjingle-0.4.0/: depcomp
Only in libjingle-0.4.0/: install-sh
Only in libjingle-0.4.0/: ltmain.sh
Only in libjingle-0.4.0/: missing
Only in libjingle/files/talk: .svn
Only in libjingle-0.4.0/talk: Makefile.in
Only in libjingle/files/talk/base: .svn
Only in libjingle-0.4.0/talk/base: Makefile.in
diff -r --ignore-space-change --strip-trailing-cr libjingle-0.4.0/talk/base/common.h libjingle/files/talk/base/common.h
54c54
< #define stdmax(x,y) max(x,y)
---
> #define stdmax(x,y) _max(x,y)
114,119d113
< // A macro to disallow the evil copy constructor and operator= functions
< // This should be used in the private: declarations for a class
< #define DISALLOW_EVIL_CONSTRUCTORS(TypeName)    \
<   TypeName(const TypeName&);                    \
<   void operator=(const TypeName&)
< 
diff -r --ignore-space-change --strip-trailing-cr libjingle-0.4.0/talk/base/diskcache_win32.cc libjingle/files/talk/base/diskcache_win32.cc
38c38
<       entry->streams = max(entry->streams, index + 1);
---
>       entry->streams = _max(entry->streams, index + 1);
diff -r --ignore-space-change --strip-trailing-cr libjingle-0.4.0/talk/base/helpers.cc libjingle/files/talk/base/helpers.cc
38a39
> #include <wincrypt.h>
diff -r --ignore-space-change --strip-trailing-cr libjingle-0.4.0/talk/base/httpclient.cc libjingle/files/talk/base/httpclient.cc
670a671
>         HttpAuthContext *context = context_.get();
676c677,678
<           *context_.use(), response, auth_method);
---
>           context, response, auth_method);
>         context_.reset(context);
diff -r --ignore-space-change --strip-trailing-cr libjingle-0.4.0/talk/base/messagequeue.cc libjingle/files/talk/base/messagequeue.cc
98,99c98,99
<     new_ss = true;
<     ss_ = new PhysicalSocketServer();
---
>     default_ss_.reset(new PhysicalSocketServer());
>     ss_ = default_ss_.get();
108,109d107
<   if (new_ss)
<     delete ss_;
113,115d110
<   if (new_ss)
<     delete ss_;
<   new_ss = false;
diff -r --ignore-space-change --strip-trailing-cr libjingle-0.4.0/talk/base/messagequeue.h libjingle/files/talk/base/messagequeue.h
35a36
> #include "talk/base/scoped_ptr.h"
192a194,195
>   // If a server isn't supplied in the constructor, use this one.
>   scoped_ptr<SocketServer> default_ss_;
diff -r --ignore-space-change --strip-trailing-cr libjingle-0.4.0/talk/base/proxydetect.cc libjingle/files/talk/base/proxydetect.cc
205,206c205,206
<   const char* list = slist.c_str();
<   while (*list) {
---
>   const char* clist = slist.c_str();
>   while (*clist) {
208,209c208,209
<     if (isspace(*list)) {
<       ++list;
---
>     if (isspace(*clist)) {
>       ++clist;
214,217c214,217
<     const char * start = list;
<     if (const char * end = strchr(list, sep)) {
<       len = (end - list);
<       list += len + 1;
---
>     const char * start = clist;
>     if (const char * end = strchr(clist, sep)) {
>       len = (end - clist);
>       clist += len + 1;
219,220c219,220
<       len = strlen(list);
<       list += len;
---
>       len = strlen(clist);
>       clist += len;
diff -r --ignore-space-change --strip-trailing-cr libjingle-0.4.0/talk/base/schanneladapter.cc libjingle/files/talk/base/schanneladapter.cc
607c607
<   size_t read = min(cb, readable.size());
---
>   size_t read = _min(cb, readable.size());
diff -r --ignore-space-change --strip-trailing-cr libjingle-0.4.0/talk/base/scoped_ptr.h libjingle/files/talk/base/scoped_ptr.h
36,257c36
< namespace talk_base {
< 
< template <typename T>
< class scoped_ptr {
<  private:
< 
<   T* ptr;
< 
<   scoped_ptr(scoped_ptr const &);
<   scoped_ptr & operator=(scoped_ptr const &);
< 
<  public:
< 
<   typedef T element_type;
< 
<   explicit scoped_ptr(T* p = 0): ptr(p) {}
< 
<   ~scoped_ptr() {
<     typedef char type_must_be_complete[sizeof(T)];
<     delete ptr;
<   }
< 
<   void reset(T* p = 0) {
<     typedef char type_must_be_complete[sizeof(T)];
< 
<     if (ptr != p) {
<       delete ptr;
<       ptr = p;
<     }
<   }
< 
<   T& operator*() const {
<     assert(ptr != 0);
<     return *ptr;
<   }
< 
<   T* operator->() const  {
<     assert(ptr != 0);
<     return ptr;
<   }
< 
<   T* get() const  {
<     return ptr;
<   }
< 
<   void swap(scoped_ptr & b) {
<     T* tmp = b.ptr;
<     b.ptr = ptr;
<     ptr = tmp;
<   }
< 
<   T* release() {
<     T* tmp = ptr;
<     ptr = 0;
<     return tmp;
<   }
<   
<   T** accept() {
<     if (ptr) {
<       delete ptr;
<       ptr = 0;
<     }
<     return &ptr;
<   }
< 
<   T** use() {
<     return &ptr;
<   }
< };
< 
< template<typename T> inline
< void swap(scoped_ptr<T>& a, scoped_ptr<T>& b) {
<   a.swap(b);
< }
< 
< 
< 
< 
< //  scoped_array extends scoped_ptr to arrays. Deletion of the array pointed to
< //  is guaranteed, either on destruction of the scoped_array or via an explicit
< //  reset(). Use shared_array or std::vector if your needs are more complex.
< 
< template<typename T>
< class scoped_array {
<  private:
< 
<   T* ptr;
< 
<   scoped_array(scoped_array const &);
<   scoped_array & operator=(scoped_array const &);
< 
<  public:
< 
<   typedef T element_type;
< 
<   explicit scoped_array(T* p = 0) : ptr(p) {}
< 
<   ~scoped_array() {
<     typedef char type_must_be_complete[sizeof(T)];
<     delete[] ptr;
<   }
< 
<   void reset(T* p = 0) {
<     typedef char type_must_be_complete[sizeof(T)];
< 
<     if (ptr != p) {
<       delete [] ptr;
<       ptr = p;
<     }
<   }
< 
<   T& operator[](std::ptrdiff_t i) const {
<     assert(ptr != 0);
<     assert(i >= 0);
<     return ptr[i];
<   }
< 
<   T* get() const {
<     return ptr;
<   }
< 
<   void swap(scoped_array & b) {
<     T* tmp = b.ptr;
<     b.ptr = ptr;
<     ptr = tmp;
<   }
< 
<   T* release() {
<     T* tmp = ptr;
<     ptr = 0;
<     return tmp;
<   }
< 
<   T** accept() {
<     if (ptr) {
<       delete [] ptr;
<       ptr = 0;
<     }
<     return &ptr;
<   }
< };
< 
< template<class T> inline
< void swap(scoped_array<T>& a, scoped_array<T>& b) {
<   a.swap(b);
< }
< 
< // scoped_ptr_malloc<> is similar to scoped_ptr<>, but it accepts a
< // second template argument, the function used to free the object.
< 
< template<typename T, void (*FF)(void*) = free> class scoped_ptr_malloc {
<  private:
< 
<   T* ptr;
< 
<   scoped_ptr_malloc(scoped_ptr_malloc const &);
<   scoped_ptr_malloc & operator=(scoped_ptr_malloc const &);
< 
<  public:
< 
<   typedef T element_type;
< 
<   explicit scoped_ptr_malloc(T* p = 0): ptr(p) {}
< 
<   ~scoped_ptr_malloc() {
<     typedef char type_must_be_complete[sizeof(T)];
<     FF(static_cast<void*>(ptr));
<   }
< 
<   void reset(T* p = 0) {
<     typedef char type_must_be_complete[sizeof(T)];
< 
<     if (ptr != p) {
<       FF(static_cast<void*>(ptr));
<       ptr = p;
<     }
<   }
< 
<   T& operator*() const {
<     assert(ptr != 0);
<     return *ptr;
<   }
< 
<   T* operator->() const {
<     assert(ptr != 0);
<     return ptr;
<   }
< 
<   T* get() const {
<     return ptr;
<   }
< 
<   void swap(scoped_ptr_malloc & b) {
<     T* tmp = b.ptr;
<     b.ptr = ptr;
<     ptr = tmp;
<   }
< 
<   T* release() {
<     T* tmp = ptr;
<     ptr = 0;
<     return tmp;
<   }
< 
<   T** accept() {
<     if (ptr) {
<       FF(static_cast<void*>(ptr));
<       ptr = 0;
<     }
<     return &ptr;
<   }
< };
< 
< template<typename T, void (*FF)(void*)> inline
< void swap(scoped_ptr_malloc<T,FF>& a, scoped_ptr_malloc<T,FF>& b) {
<   a.swap(b);
< }
< 
< } // namespace talk_base
< 
< // TODO: get rid of this global using 
< using talk_base::scoped_ptr;
---
> #include "base/scoped_ptr.h"
diff -r --ignore-space-change --strip-trailing-cr libjingle-0.4.0/talk/base/socket.h libjingle/files/talk/base/socket.h
77a78
> #undef ETIMEDOUT // remove pthread.h's definition
diff -r --ignore-space-change --strip-trailing-cr libjingle-0.4.0/talk/base/stringutils.h libjingle/files/talk/base/stringutils.h
87a88
> #if 0
93a95
> #endif
diff -r --ignore-space-change --strip-trailing-cr libjingle-0.4.0/talk/base/task.cc libjingle/files/talk/base/task.cc
141c141
<   if (aborted_ || done_)
---
>   if (done_)
150c150
<       Wake();  // to self-delete
---
>       GetRunner()->WakeTasks();
diff -r --ignore-space-change --strip-trailing-cr libjingle-0.4.0/talk/base/winping.cc libjingle/files/talk/base/winping.cc
133c133
<   return sizeof(ICMP_ECHO_REPLY) + max(8UL, data_size);
---
>   return sizeof(ICMP_ECHO_REPLY) + _max((uint32)(8UL), data_size);
Only in libjingle-0.4.0/talk: examples
Only in libjingle-0.4.0/talk: libjingle.sln
Only in libjingle-0.4.0/talk: libjingle.vcproj
Only in libjingle/files/talk/p2p: .svn
Only in libjingle-0.4.0/talk/p2p: Makefile.in
Only in libjingle/files/talk/p2p/base: .svn
Only in libjingle-0.4.0/talk/p2p/base: Makefile.in
diff -r --ignore-space-change --strip-trailing-cr libjingle-0.4.0/talk/p2p/base/port.cc libjingle/files/talk/p2p/base/port.cc
270c270
<   talk_base::scoped_ptr<StunMessage> stun_msg(new StunMessage());
---
>   scoped_ptr<StunMessage> stun_msg(new StunMessage());
Only in libjingle/files/talk/p2p/client: .svn
Only in libjingle-0.4.0/talk/p2p/client: Makefile.in
diff -r --ignore-space-change --strip-trailing-cr libjingle-0.4.0/talk/p2p/client/httpportallocator.cc libjingle/files/talk/p2p/client/httpportallocator.cc
82c82
<   relay_hosts_.push_back("relay.l.google.com");
---
>   relay_hosts_.push_back("relay.google.com");
Only in libjingle-0.4.0/talk: session
Only in libjingle-0.4.0/talk: third_party
Only in libjingle/files/talk/xmllite: .svn
Only in libjingle-0.4.0/talk/xmllite: Makefile.in
diff -r --ignore-space-change --strip-trailing-cr libjingle-0.4.0/talk/xmllite/qname.cc libjingle/files/talk/xmllite/qname.cc
39c39
<   int result = ns.size() * 101;
---
>   int result = static_cast<int>(ns.size()) * 101;
diff -r --ignore-space-change --strip-trailing-cr libjingle-0.4.0/talk/xmllite/xmlelement.cc libjingle/files/talk/xmllite/xmlelement.cc
88c88,89
<     pLastChild_(NULL) {
---
>     pLastChild_(NULL),
>     cdata_(false) {
97c98,99
<     pLastChild_(NULL) {
---
>     pLastChild_(NULL),
>     cdata_(false) {
125a128
>   cdata_ = elt.cdata_;
133c136,137
<   pLastChild_(NULL) {
---
>   pLastChild_(NULL),
>   cdata_(false) {
393a398,403
> XmlElement::AddCDATAText(const char * buf, int len) {
>   cdata_ = true;
>   AddParsedText(buf, len);
> }
> 
> void
diff -r --ignore-space-change --strip-trailing-cr libjingle-0.4.0/talk/xmllite/xmlelement.h libjingle/files/talk/xmllite/xmlelement.h
203a204,206
>   // Note: CDATA is not supported by XMPP, therefore using this function will
>   // generate non-XMPP compatible XML.
>   void AddCDATAText(const char * buf, int len);
217a221,222
>   bool IsCDATA() const { return cdata_; }
> 
228a234
>   bool cdata_;
diff -r --ignore-space-change --strip-trailing-cr libjingle-0.4.0/talk/xmllite/xmlparser.cc libjingle/files/talk/xmllite/xmlparser.cc
28,29d27
< #include "talk/xmllite/xmlparser.h"
< 
35a34
> #include "talk/xmllite/xmlconstants.h"
38c37
< #include "talk/xmllite/xmlconstants.h"
---
> #include "talk/xmllite/xmlparser.h"
119a119,121
>   context_.SetPosition(XML_GetCurrentLineNumber(expat_),
>                        XML_GetCurrentColumnNumber(expat_),
>                        XML_GetCurrentByteIndex(expat_));
127a130,132
>   context_.SetPosition(XML_GetCurrentLineNumber(expat_),
>                        XML_GetCurrentColumnNumber(expat_),
>                        XML_GetCurrentByteIndex(expat_));
134a140,142
>   context_.SetPosition(XML_GetCurrentLineNumber(expat_),
>                        XML_GetCurrentColumnNumber(expat_),
>                        XML_GetCurrentByteIndex(expat_));
168c176,180
<   if (XML_Parse(expat_, data, static_cast<int>(len), isFinal) != XML_STATUS_OK)
---
>   if (XML_Parse(expat_, data, static_cast<int>(len), isFinal) !=
>       XML_STATUS_OK) {
>     context_.SetPosition(XML_GetCurrentLineNumber(expat_),
>                          XML_GetCurrentColumnNumber(expat_),
>                          XML_GetCurrentByteIndex(expat_));
169a182
>   }
193c206,209
<     raised_(XML_ERROR_NONE) {
---
>     raised_(XML_ERROR_NONE),
>     line_number_(0),
>     column_number_(0),
>     byte_index_(0) {
247c263,285
< XmlParser::ParseContext::~ParseContext() {
---
> void
> XmlParser::ParseContext::SetPosition(XML_Size line, XML_Size column,
>                                      XML_Index byte_index) {
>   line_number_ = line;
>   column_number_ = column;
>   byte_index_ = byte_index;
> }
> 
> void
> XmlParser::ParseContext::GetPosition(unsigned long * line,
>                                      unsigned long * column,
>                                      unsigned long * byte_index) {
>   if (line != NULL) {
>     *line = static_cast<unsigned long>(line_number_);
>   }
> 
>   if (column != NULL) {
>     *column = static_cast<unsigned long>(column_number_);
>   }
> 
>   if (byte_index != NULL) {
>     *byte_index = static_cast<unsigned long>(byte_index_);
>   }
249a288
> XmlParser::ParseContext::~ParseContext() {
251a291
> }
diff -r --ignore-space-change --strip-trailing-cr libjingle-0.4.0/talk/xmllite/xmlparser.h libjingle/files/talk/xmllite/xmlparser.h
48a49,50
>   virtual void GetPosition(unsigned long * line, unsigned long * column,
>                            unsigned long * byte_index) = 0;
85a88,89
>     virtual void GetPosition(unsigned long * line, unsigned long * column,
>                              unsigned long * byte_index);
91a96
>     void SetPosition(XML_Size line, XML_Size column, XML_Index byte_index);
96a102,104
>     XML_Size line_number_;
>     XML_Size column_number_;
>     XML_Index byte_index_;
diff -r --ignore-space-change --strip-trailing-cr libjingle-0.4.0/talk/xmllite/xmlprinter.cc libjingle/files/talk/xmllite/xmlprinter.cc
46a47
>   void PrintCDATAText(const std::string & text);
134c135,138
<       if (pchild->IsText())
---
>       if (pchild->IsText()) {
>         if (element->IsCDATA()) {
>           PrintCDATAText(pchild->AsText()->Text());
>         } else {
136c140,141
<       else
---
>         }
>       } else
188a194,197
> void
> XmlPrinterImpl::PrintCDATAText(const std::string & text) {
>   *pout_ << "<![CDATA[" << text << "]]>";
> }
Only in libjingle/files/talk/xmpp: .svn
Only in libjingle-0.4.0/talk/xmpp: Makefile.in
diff -r --ignore-space-change --strip-trailing-cr libjingle-0.4.0/talk/xmpp/constants.cc libjingle/files/talk/xmpp/constants.cc
206a207,209
> const std::string NS_GOOGLE_AUTH_PROTOCOL("http://www.google.com/talk/protocol/auth");
> const QName QN_GOOGLE_AUTH_CLIENT_USES_FULL_BIND_RESULT(true, NS_GOOGLE_AUTH_PROTOCOL, "client-uses-full-bind-result");
> 
208a212
> const QName QN_GOOGLE_ALLOW_NON_GOOGLE_ID_XMPP_LOGIN(true, NS_GOOGLE_AUTH_PROTOCOL, "allow-non-google-login");
diff -r --ignore-space-change --strip-trailing-cr libjingle-0.4.0/talk/xmpp/constants.h libjingle/files/talk/xmpp/constants.h
175a176,178
> extern const std::string NS_GOOGLE_AUTH_PROTOCOL;
> extern const QName QN_GOOGLE_AUTH_CLIENT_USES_FULL_BIND_RESULT;
> extern const QName QN_GOOGLE_ALLOW_NON_GOOGLE_ID_XMPP_LOGIN;
diff -r --ignore-space-change --strip-trailing-cr libjingle-0.4.0/talk/xmpp/saslcookiemechanism.h libjingle/files/talk/xmpp/saslcookiemechanism.h
40,41c40,55
<   SaslCookieMechanism(const std::string & mechanism, const std::string & username, const std::string & cookie) :
<     mechanism_(mechanism), username_(username), cookie_(cookie) {}
---
>   SaslCookieMechanism(const std::string & mechanism,
>                       const std::string & username,
>                       const std::string & cookie,
>                       const std::string & token_service)
>     : mechanism_(mechanism),
>       username_(username),
>       cookie_(cookie),
>       token_service_(token_service) {}
> 
>   SaslCookieMechanism(const std::string & mechanism,
>                       const std::string & username,
>                       const std::string & cookie)
>     : mechanism_(mechanism),
>       username_(username),
>       cookie_(cookie),
>       token_service_("") {}
48a63,67
>     if (!token_service_.empty()) {
>       el->AddAttr(
>           QName(true, "http://www.google.com/talk/protocol/auth", "service"),
>           token_service_);
>     }
62a82
>   std::string token_service_;
diff -r --ignore-space-change --strip-trailing-cr libjingle-0.4.0/talk/xmpp/saslhandler.h libjingle/files/talk/xmpp/saslhandler.h
31a32
> #include <vector>
diff -r --ignore-space-change --strip-trailing-cr libjingle-0.4.0/talk/xmpp/xmppclientsettings.h libjingle/files/talk/xmpp/xmppclientsettings.h
59a60,62
>   void set_token_service(const std::string & token_service) {
>     token_service_ = token_service;
>   }
75a79
>   const std::string & token_service() const { return token_service_; }
93a98
>   std::string token_service_;
diff -r --ignore-space-change --strip-trailing-cr libjingle-0.4.0/talk/xmpp/xmpplogintask.cc libjingle/files/talk/xmpp/xmpplogintask.cc
218a219,221
>         auth->SetAttr(QN_GOOGLE_ALLOW_NON_GOOGLE_ID_XMPP_LOGIN, "true");
>         auth->SetAttr(QN_GOOGLE_AUTH_CLIENT_USES_FULL_BIND_RESULT, "true");
> 
