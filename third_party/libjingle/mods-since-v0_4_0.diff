Only in libjingle/files/: .svn
Only in libjingle-0.4.0/: Makefile.in
diff -r libjingle-0.4.0/README libjingle/files/README
1,39c1,39
< Libjingle
< 
< Libjingle is a set of components provided by Google to interoperate with Google
< Talk's peer-to-peer and voice capabilities. This package will create several
< static libraries you may link to your project as needed.
< 
< -talk               - No source files in talk/, just these subdirectories
< |-base              - Contains basic low-level portable utility functions for 
< |                     things like threads and sockets
< |-p2p               - The P2P stack
<   |-base            - Base p2p functionality
<   |-client          - Hooks to tie it into XMPP
< |-session           - Signaling
<   |-phone           - Signaling code specific to making phone calls
< |-third_party       - Components that aren't ours
<   |-mediastreamer   - Media components for dealing with sound hardware and 
<   |                   voice codecs
< |-xmllite           - XML parser
< |-xmpp              - XMPP engine
< 
< In addition, this package contains two examples in talk/examples which 
< illustrate the basic concepts of how the provided classes work.
< 
< The xmllite component of libjingle depends on expat. You can download expat 
< from http://expat.sourceforge.net/.
< 
< mediastreamer, the media components used by the example applications depend on
< the oRTP and iLBC components from linphone, which can be found at 
< http://www.linphone.org. Linphone, in turn depends on GLib, which can be found
< at http://www.gtk.org. This GLib dependency should be removed in future 
< releases.
< 
< Building Libjingle
< 
< Once the dependencies are installed, run ./configure. ./configure will return
< an error if it failed to locate the proper dependencies. If ./configure
< succeeds, run 'make' to build the components and examples.
< 
< When the build is complete, you can run the call example from 
---
> Libjingle
> 
> Libjingle is a set of components provided by Google to interoperate with Google
> Talk's peer-to-peer and voice capabilities. This package will create several
> static libraries you may link to your project as needed.
> 
> -talk               - No source files in talk/, just these subdirectories
> |-base              - Contains basic low-level portable utility functions for 
> |                     things like threads and sockets
> |-p2p               - The P2P stack
>   |-base            - Base p2p functionality
>   |-client          - Hooks to tie it into XMPP
> |-session           - Signaling
>   |-phone           - Signaling code specific to making phone calls
> |-third_party       - Components that aren't ours
>   |-mediastreamer   - Media components for dealing with sound hardware and 
>   |                   voice codecs
> |-xmllite           - XML parser
> |-xmpp              - XMPP engine
> 
> In addition, this package contains two examples in talk/examples which 
> illustrate the basic concepts of how the provided classes work.
> 
> The xmllite component of libjingle depends on expat. You can download expat 
> from http://expat.sourceforge.net/.
> 
> mediastreamer, the media components used by the example applications depend on
> the oRTP and iLBC components from linphone, which can be found at 
> http://www.linphone.org. Linphone, in turn depends on GLib, which can be found
> at http://www.gtk.org. This GLib dependency should be removed in future 
> releases.
> 
> Building Libjingle
> 
> Once the dependencies are installed, run ./configure. ./configure will return
> an error if it failed to locate the proper dependencies. If ./configure
> succeeds, run 'make' to build the components and examples.
> 
> When the build is complete, you can run the call example from 
41,57c41,57
< 
< Relay Server
< 
< Libjingle will also build a relay server that may be used to relay traffic
< when a direct peer-to-peer connection could not be established. The relay
< server will build in talk/p2p/base/relayserver and will listen on UDP
< ports 5000 and 5001. See the Libjingle Developer Guide at 
< http://code.google.com/apis/talk/index.html for information about configuring
< a client to use this relay server.
< 
< STUN Server
< 
< Lastly, Libjingle builds a STUN server which implements the STUN protocol for
< Simple Traversal of UDP over NAT. The STUN server is built as
< talk/p2p/base/stunserver and listens on UDP port 7000. See the Libjingle
< Developer Guide at http://code.google.com/apis/talk/index.html for information
< about configuring a client to use this STUN server.
---
> 
> Relay Server
> 
> Libjingle will also build a relay server that may be used to relay traffic
> when a direct peer-to-peer connection could not be established. The relay
> server will build in talk/p2p/base/relayserver and will listen on UDP
> ports 5000 and 5001. See the Libjingle Developer Guide at 
> http://code.google.com/apis/talk/index.html for information about configuring
> a client to use this relay server.
> 
> STUN Server
> 
> Lastly, Libjingle builds a STUN server which implements the STUN protocol for
> Simple Traversal of UDP over NAT. The STUN server is built as
> talk/p2p/base/stunserver and listens on UDP port 7000. See the Libjingle
> Developer Guide at http://code.google.com/apis/talk/index.html for information
> about configuring a client to use this STUN server.
diff -r libjingle-0.4.0/README.win libjingle/files/README.win
1,24c1,24
< 1. Install Visual C++ Express 2005.  It is free from this link:
<    http://msdn.microsoft.com/vstudio/express/visualc/
< 
< 2. Install the platform SDK and integrate it into VC++ express
<    http://msdn.microsoft.com/vstudio/express/visualc/usingpsdk/
< 
< 3. Download and install binary package for expat:
<    http://sourceforge.net/project/showfiles.php?group_id=10127&package_id=11277
< 
< 4. Update the Visual C++ directories in the Projects and Solutions section in the Options dialog box
<    Library files: C:\expat-VERSION\StaticLibs
<    Include files: C:\expat-VERSION\Source\Lib
<    where VERSION is the version of expat you've downoaded
< 
< 5. Unzip the libjingle files and open the solution.
< 
< 6. If you wish to build the call example with GIPS Voice Engine Lite, download Voice Engine Lite from http://developer.globalipsound.com
< 
< 7. Extract the Interface and Library directories from the Voice Engine Lite zip file into talk\third_party\gips
< 
< 8. Open talk\third_party\gips\expiration.h and set the GIPS_EXPIRATION #defines to the expiration date provided by GIPS and remove the #error directive
< 
< 9. Build the solution
< 
---
> 1. Install Visual C++ Express 2005.  It is free from this link:
>    http://msdn.microsoft.com/vstudio/express/visualc/
> 
> 2. Install the platform SDK and integrate it into VC++ express
>    http://msdn.microsoft.com/vstudio/express/visualc/usingpsdk/
> 
> 3. Download and install binary package for expat:
>    http://sourceforge.net/project/showfiles.php?group_id=10127&package_id=11277
> 
> 4. Update the Visual C++ directories in the Projects and Solutions section in the Options dialog box
>    Library files: C:\expat-VERSION\StaticLibs
>    Include files: C:\expat-VERSION\Source\Lib
>    where VERSION is the version of expat you've downoaded
> 
> 5. Unzip the libjingle files and open the solution.
> 
> 6. If you wish to build the call example with GIPS Voice Engine Lite, download Voice Engine Lite from http://developer.globalipsound.com
> 
> 7. Extract the Interface and Library directories from the Voice Engine Lite zip file into talk\third_party\gips
> 
> 8. Open talk\third_party\gips\expiration.h and set the GIPS_EXPIRATION #defines to the expiration date provided by GIPS and remove the #error directive
> 
> 9. Build the solution
> 
Only in libjingle-0.4.0/: aclocal.m4
Only in libjingle-0.4.0/: config.guess
diff -r libjingle-0.4.0/config.h libjingle/files/config.h
14c14
< #define HAVE_ALSA_ASOUNDLIB_H 1
---
> /* #undef HAVE_ALSA_ASOUNDLIB_H */
23c23
< #define HAVE_GLIB 1
---
> /* #undef HAVE_GLIB */
38c38
< #define HAVE_ORTP 1
---
> /* #undef HAVE_ORTP */
41c41
< #define HAVE_SPEEX 1
---
> /* #undef HAVE_SPEEX */
47c47
< #define HAVE_SPEEX_SPEEX_H 1
---
> /* #undef HAVE_SPEEX_SPEEX_H */
71c71
< #define LINUX 1
---
> /* #undef LINUX */
113c113
< #define __ALSA_ENABLED__ 1
---
> /* #undef __ALSA_ENABLED__ */
Only in libjingle-0.4.0/: config.h.in
Only in libjingle-0.4.0/: config.sub
Only in libjingle-0.4.0/: configure
Only in libjingle-0.4.0/: depcomp
Only in libjingle-0.4.0/: install-sh
Only in libjingle-0.4.0/: ltmain.sh
Only in libjingle-0.4.0/: missing
Only in libjingle/files/talk: .svn
Only in libjingle-0.4.0/talk: Makefile.in
Only in libjingle/files/talk/base: .svn
Only in libjingle-0.4.0/talk/base: Makefile.in
diff -r libjingle-0.4.0/talk/base/base64.h libjingle/files/talk/base/base64.h
26,27c26,27
<   static const std::string Base64::Base64Table;
<   static const std::string::size_type Base64::DecodeTable[];
---
>   static const std::string Base64Table;
>   static const std::string::size_type DecodeTable[];
diff -r libjingle-0.4.0/talk/base/common.h libjingle/files/talk/base/common.h
54c54
< #define stdmax(x,y) max(x,y)
---
> #define stdmax(x,y) _max(x,y)
114,119d113
< // A macro to disallow the evil copy constructor and operator= functions
< // This should be used in the private: declarations for a class
< #define DISALLOW_EVIL_CONSTRUCTORS(TypeName)    \
<   TypeName(const TypeName&);                    \
<   void operator=(const TypeName&)
< 
diff -r libjingle-0.4.0/talk/base/diskcache_win32.cc libjingle/files/talk/base/diskcache_win32.cc
38c38
<       entry->streams = max(entry->streams, index + 1);
---
>       entry->streams = _max(entry->streams, index + 1);
diff -r libjingle-0.4.0/talk/base/helpers.cc libjingle/files/talk/base/helpers.cc
38a39
> #include <wincrypt.h>
diff -r libjingle-0.4.0/talk/base/httpclient.cc libjingle/files/talk/base/httpclient.cc
670a671
>         HttpAuthContext *context = context_.get();
676c677,678
<           *context_.use(), response, auth_method);
---
>           context, response, auth_method);
>         context_.reset(context);
diff -r libjingle-0.4.0/talk/base/messagequeue.cc libjingle/files/talk/base/messagequeue.cc
98,99c98,99
<     new_ss = true;
<     ss_ = new PhysicalSocketServer();
---
>     default_ss_.reset(new PhysicalSocketServer());
>     ss_ = default_ss_.get();
108,109d107
<   if (new_ss)
<     delete ss_;
113,115d110
<   if (new_ss)
<     delete ss_;
<   new_ss = false;
diff -r libjingle-0.4.0/talk/base/messagequeue.h libjingle/files/talk/base/messagequeue.h
35a36
> #include "talk/base/scoped_ptr.h"
192a194,195
>   // If a server isn't supplied in the constructor, use this one.
>   scoped_ptr<SocketServer> default_ss_;
diff -r libjingle-0.4.0/talk/base/proxydetect.cc libjingle/files/talk/base/proxydetect.cc
205,206c205,206
<   const char* list = slist.c_str();
<   while (*list) {
---
>   const char* clist = slist.c_str();
>   while (*clist) {
208,209c208,209
<     if (isspace(*list)) {
<       ++list;
---
>     if (isspace(*clist)) {
>       ++clist;
214,217c214,217
<     const char * start = list;
<     if (const char * end = strchr(list, sep)) {
<       len = (end - list);
<       list += len + 1;
---
>     const char * start = clist;
>     if (const char * end = strchr(clist, sep)) {
>       len = (end - clist);
>       clist += len + 1;
219,220c219,220
<       len = strlen(list);
<       list += len;
---
>       len = strlen(clist);
>       clist += len;
diff -r libjingle-0.4.0/talk/base/schanneladapter.cc libjingle/files/talk/base/schanneladapter.cc
607c607
<   size_t read = min(cb, readable.size());
---
>   size_t read = _min(cb, readable.size());
diff -r libjingle-0.4.0/talk/base/scoped_ptr.h libjingle/files/talk/base/scoped_ptr.h
36,257c36
< namespace talk_base {
< 
< template <typename T>
< class scoped_ptr {
<  private:
< 
<   T* ptr;
< 
<   scoped_ptr(scoped_ptr const &);
<   scoped_ptr & operator=(scoped_ptr const &);
< 
<  public:
< 
<   typedef T element_type;
< 
<   explicit scoped_ptr(T* p = 0): ptr(p) {}
< 
<   ~scoped_ptr() {
<     typedef char type_must_be_complete[sizeof(T)];
<     delete ptr;
<   }
< 
<   void reset(T* p = 0) {
<     typedef char type_must_be_complete[sizeof(T)];
< 
<     if (ptr != p) {
<       delete ptr;
<       ptr = p;
<     }
<   }
< 
<   T& operator*() const {
<     assert(ptr != 0);
<     return *ptr;
<   }
< 
<   T* operator->() const  {
<     assert(ptr != 0);
<     return ptr;
<   }
< 
<   T* get() const  {
<     return ptr;
<   }
< 
<   void swap(scoped_ptr & b) {
<     T* tmp = b.ptr;
<     b.ptr = ptr;
<     ptr = tmp;
<   }
< 
<   T* release() {
<     T* tmp = ptr;
<     ptr = 0;
<     return tmp;
<   }
<   
<   T** accept() {
<     if (ptr) {
<       delete ptr;
<       ptr = 0;
<     }
<     return &ptr;
<   }
< 
<   T** use() {
<     return &ptr;
<   }
< };
< 
< template<typename T> inline
< void swap(scoped_ptr<T>& a, scoped_ptr<T>& b) {
<   a.swap(b);
< }
< 
< 
< 
< 
< //  scoped_array extends scoped_ptr to arrays. Deletion of the array pointed to
< //  is guaranteed, either on destruction of the scoped_array or via an explicit
< //  reset(). Use shared_array or std::vector if your needs are more complex.
< 
< template<typename T>
< class scoped_array {
<  private:
< 
<   T* ptr;
< 
<   scoped_array(scoped_array const &);
<   scoped_array & operator=(scoped_array const &);
< 
<  public:
< 
<   typedef T element_type;
< 
<   explicit scoped_array(T* p = 0) : ptr(p) {}
< 
<   ~scoped_array() {
<     typedef char type_must_be_complete[sizeof(T)];
<     delete[] ptr;
<   }
< 
<   void reset(T* p = 0) {
<     typedef char type_must_be_complete[sizeof(T)];
< 
<     if (ptr != p) {
<       delete [] ptr;
<       ptr = p;
<     }
<   }
< 
<   T& operator[](std::ptrdiff_t i) const {
<     assert(ptr != 0);
<     assert(i >= 0);
<     return ptr[i];
<   }
< 
<   T* get() const {
<     return ptr;
<   }
< 
<   void swap(scoped_array & b) {
<     T* tmp = b.ptr;
<     b.ptr = ptr;
<     ptr = tmp;
<   }
< 
<   T* release() {
<     T* tmp = ptr;
<     ptr = 0;
<     return tmp;
<   }
< 
<   T** accept() {
<     if (ptr) {
<       delete [] ptr;
<       ptr = 0;
<     }
<     return &ptr;
<   }
< };
< 
< template<class T> inline
< void swap(scoped_array<T>& a, scoped_array<T>& b) {
<   a.swap(b);
< }
< 
< // scoped_ptr_malloc<> is similar to scoped_ptr<>, but it accepts a
< // second template argument, the function used to free the object.
< 
< template<typename T, void (*FF)(void*) = free> class scoped_ptr_malloc {
<  private:
< 
<   T* ptr;
< 
<   scoped_ptr_malloc(scoped_ptr_malloc const &);
<   scoped_ptr_malloc & operator=(scoped_ptr_malloc const &);
< 
<  public:
< 
<   typedef T element_type;
< 
<   explicit scoped_ptr_malloc(T* p = 0): ptr(p) {}
< 
<   ~scoped_ptr_malloc() {
<     typedef char type_must_be_complete[sizeof(T)];
<     FF(static_cast<void*>(ptr));
<   }
< 
<   void reset(T* p = 0) {
<     typedef char type_must_be_complete[sizeof(T)];
< 
<     if (ptr != p) {
<       FF(static_cast<void*>(ptr));
<       ptr = p;
<     }
<   }
< 
<   T& operator*() const {
<     assert(ptr != 0);
<     return *ptr;
<   }
< 
<   T* operator->() const {
<     assert(ptr != 0);
<     return ptr;
<   }
< 
<   T* get() const {
<     return ptr;
<   }
< 
<   void swap(scoped_ptr_malloc & b) {
<     T* tmp = b.ptr;
<     b.ptr = ptr;
<     ptr = tmp;
<   }
< 
<   T* release() {
<     T* tmp = ptr;
<     ptr = 0;
<     return tmp;
<   }
< 
<   T** accept() {
<     if (ptr) {
<       FF(static_cast<void*>(ptr));
<       ptr = 0;
<     }
<     return &ptr;
<   }
< };
< 
< template<typename T, void (*FF)(void*)> inline
< void swap(scoped_ptr_malloc<T,FF>& a, scoped_ptr_malloc<T,FF>& b) {
<   a.swap(b);
< }
< 
< } // namespace talk_base
< 
< // TODO: get rid of this global using 
< using talk_base::scoped_ptr;
---
> #include "base/scoped_ptr.h"
diff -r libjingle-0.4.0/talk/base/socket.h libjingle/files/talk/base/socket.h
77a78
> #undef ETIMEDOUT // remove pthread.h's definition
diff -r libjingle-0.4.0/talk/base/stringutils.h libjingle/files/talk/base/stringutils.h
87a88
> #if 0
93a95
> #endif
272c274
<   inline static const char* Traits<char>::empty_str() { return ""; }
---
>   inline static const char* empty_str() { return ""; }
diff -r libjingle-0.4.0/talk/base/task.cc libjingle/files/talk/base/task.cc
5c5
<  * Redistribution and use in source and binary forms, with or without 
---
>  * Redistribution and use in source and binary forms, with or without
8c8
<  *  1. Redistributions of source code must retain the above copyright notice, 
---
>  *  1. Redistributions of source code must retain the above copyright notice,
13c13
<  *  3. The name of the author may not be used to endorse or promote products 
---
>  *  3. The name of the author may not be used to endorse or promote products
17c17
<  * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF 
---
>  * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
19c19
<  * EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
---
>  * EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
23,24c23,24
<  * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR 
<  * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF 
---
>  * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
>  * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
141c141
<   if (aborted_ || done_)
---
>   if (done_)
150c150
<       Wake();  // to self-delete
---
>       GetRunner()->WakeTasks();
diff -r libjingle-0.4.0/talk/base/winping.cc libjingle/files/talk/base/winping.cc
133c133
<   return sizeof(ICMP_ECHO_REPLY) + max(8UL, data_size);
---
>   return sizeof(ICMP_ECHO_REPLY) + _max((uint32)(8UL), data_size);
317c317
< } // namespace talk_base
\ No newline at end of file
---
> } // namespace talk_base
Only in libjingle-0.4.0/talk: examples
Only in libjingle-0.4.0/talk: libjingle.sln
Only in libjingle-0.4.0/talk: libjingle.vcproj
Only in libjingle/files/talk/p2p: .svn
Only in libjingle-0.4.0/talk/p2p: Makefile.in
Only in libjingle/files/talk/p2p/base: .svn
Only in libjingle-0.4.0/talk/p2p/base: Makefile.in
diff -r libjingle-0.4.0/talk/p2p/base/port.cc libjingle/files/talk/p2p/base/port.cc
270c270
<   talk_base::scoped_ptr<StunMessage> stun_msg(new StunMessage());
---
>   scoped_ptr<StunMessage> stun_msg(new StunMessage());
diff -r libjingle-0.4.0/talk/p2p/base/sessionmanager.h libjingle/files/talk/p2p/base/sessionmanager.h
159c159
<   buzz::XmlElement* SessionManager::CreateErrorMessage(
---
>   buzz::XmlElement* CreateErrorMessage(
Only in libjingle/files/talk/p2p/client: .svn
Only in libjingle-0.4.0/talk/p2p/client: Makefile.in
diff -r libjingle-0.4.0/talk/p2p/client/httpportallocator.cc libjingle/files/talk/p2p/client/httpportallocator.cc
82c82
<   relay_hosts_.push_back("relay.l.google.com");
---
>   relay_hosts_.push_back("relay.google.com");
Only in libjingle-0.4.0/talk: session
Only in libjingle-0.4.0/talk: third_party
Only in libjingle/files/talk/xmllite: .svn
Only in libjingle-0.4.0/talk/xmllite: Makefile.in
diff -r libjingle-0.4.0/talk/xmllite/qname.cc libjingle/files/talk/xmllite/qname.cc
39c39
<   int result = ns.size() * 101;
---
>   int result = static_cast<int>(ns.size()) * 101;
diff -r libjingle-0.4.0/talk/xmllite/qname.h libjingle/files/talk/xmllite/qname.h
64d63
<       refcount_(1),
66c65,66
<       localPart_(local) {}
---
>       localPart_(local),
>       refcount_(1) {}
diff -r libjingle-0.4.0/talk/xmllite/xmlelement.cc libjingle/files/talk/xmllite/xmlelement.cc
88c88,89
<     pLastChild_(NULL) {
---
>     pLastChild_(NULL),
>     cdata_(false) {
97c98,99
<     pLastChild_(NULL) {
---
>     pLastChild_(NULL),
>     cdata_(false) {
125a128
>   cdata_ = elt.cdata_;
133c136,137
<   pLastChild_(NULL) {
---
>   pLastChild_(NULL),
>   cdata_(false) {
393a398,403
> XmlElement::AddCDATAText(const char * buf, int len) {
>   cdata_ = true;
>   AddParsedText(buf, len);
> }
> 
> void
diff -r libjingle-0.4.0/talk/xmllite/xmlelement.h libjingle/files/talk/xmllite/xmlelement.h
203a204,206
>   // Note: CDATA is not supported by XMPP, therefore using this function will
>   // generate non-XMPP compatible XML.
>   void AddCDATAText(const char * buf, int len);
217a221,222
>   bool IsCDATA() const { return cdata_; }
> 
228a234
>   bool cdata_;
diff -r libjingle-0.4.0/talk/xmllite/xmlparser.cc libjingle/files/talk/xmllite/xmlparser.cc
28,29d27
< #include "talk/xmllite/xmlparser.h"
< 
35a34
> #include "talk/xmllite/xmlconstants.h"
38c37
< #include "talk/xmllite/xmlconstants.h"
---
> #include "talk/xmllite/xmlparser.h"
119a119,121
>   context_.SetPosition(XML_GetCurrentLineNumber(expat_),
>                        XML_GetCurrentColumnNumber(expat_),
>                        XML_GetCurrentByteIndex(expat_));
127a130,132
>   context_.SetPosition(XML_GetCurrentLineNumber(expat_),
>                        XML_GetCurrentColumnNumber(expat_),
>                        XML_GetCurrentByteIndex(expat_));
134a140,142
>   context_.SetPosition(XML_GetCurrentLineNumber(expat_),
>                        XML_GetCurrentColumnNumber(expat_),
>                        XML_GetCurrentByteIndex(expat_));
168c176,180
<   if (XML_Parse(expat_, data, static_cast<int>(len), isFinal) != XML_STATUS_OK)
---
>   if (XML_Parse(expat_, data, static_cast<int>(len), isFinal) !=
>       XML_STATUS_OK) {
>     context_.SetPosition(XML_GetCurrentLineNumber(expat_),
>                          XML_GetCurrentColumnNumber(expat_),
>                          XML_GetCurrentByteIndex(expat_));
169a182
>   }
193c206,209
<     raised_(XML_ERROR_NONE) {
---
>     raised_(XML_ERROR_NONE),
>     line_number_(0),
>     column_number_(0),
>     byte_index_(0) {
247c263,285
< XmlParser::ParseContext::~ParseContext() {
---
> void
> XmlParser::ParseContext::SetPosition(XML_Size line, XML_Size column,
>                                      XML_Index byte_index) {
>   line_number_ = line;
>   column_number_ = column;
>   byte_index_ = byte_index;
> }
> 
> void
> XmlParser::ParseContext::GetPosition(unsigned long * line,
>                                      unsigned long * column,
>                                      unsigned long * byte_index) {
>   if (line != NULL) {
>     *line = static_cast<unsigned long>(line_number_);
>   }
> 
>   if (column != NULL) {
>     *column = static_cast<unsigned long>(column_number_);
>   }
> 
>   if (byte_index != NULL) {
>     *byte_index = static_cast<unsigned long>(byte_index_);
>   }
249a288
> XmlParser::ParseContext::~ParseContext() {
251a291
> }
diff -r libjingle-0.4.0/talk/xmllite/xmlparser.h libjingle/files/talk/xmllite/xmlparser.h
48a49,50
>   virtual void GetPosition(unsigned long * line, unsigned long * column,
>                            unsigned long * byte_index) = 0;
85a88,89
>     virtual void GetPosition(unsigned long * line, unsigned long * column,
>                              unsigned long * byte_index);
91a96
>     void SetPosition(XML_Size line, XML_Size column, XML_Index byte_index);
96a102,104
>     XML_Size line_number_;
>     XML_Size column_number_;
>     XML_Index byte_index_;
diff -r libjingle-0.4.0/talk/xmllite/xmlprinter.cc libjingle/files/talk/xmllite/xmlprinter.cc
46a47
>   void PrintCDATAText(const std::string & text);
134,136c135,141
<       if (pchild->IsText())
<         PrintBodyText(pchild->AsText()->Text());
<       else
---
>       if (pchild->IsText()) {
>         if (element->IsCDATA()) {
>           PrintCDATAText(pchild->AsText()->Text());
>         } else {
>           PrintBodyText(pchild->AsText()->Text());
>         }
>       } else
188a194,197
> void
> XmlPrinterImpl::PrintCDATAText(const std::string & text) {
>   *pout_ << "<![CDATA[" << text << "]]>";
> }
Only in libjingle/files/talk/xmpp: .svn
Only in libjingle-0.4.0/talk/xmpp: Makefile.in
diff -r libjingle-0.4.0/talk/xmpp/constants.cc libjingle/files/talk/xmpp/constants.cc
206a207,209
> const std::string NS_GOOGLE_AUTH_PROTOCOL("http://www.google.com/talk/protocol/auth");
> const QName QN_GOOGLE_AUTH_CLIENT_USES_FULL_BIND_RESULT(true, NS_GOOGLE_AUTH_PROTOCOL, "client-uses-full-bind-result");
> 
208a212
> const QName QN_GOOGLE_ALLOW_NON_GOOGLE_ID_XMPP_LOGIN(true, NS_GOOGLE_AUTH_PROTOCOL, "allow-non-google-login");
diff -r libjingle-0.4.0/talk/xmpp/constants.h libjingle/files/talk/xmpp/constants.h
175a176,178
> extern const std::string NS_GOOGLE_AUTH_PROTOCOL;
> extern const QName QN_GOOGLE_AUTH_CLIENT_USES_FULL_BIND_RESULT;
> extern const QName QN_GOOGLE_ALLOW_NON_GOOGLE_ID_XMPP_LOGIN;
diff -r libjingle-0.4.0/talk/xmpp/saslcookiemechanism.h libjingle/files/talk/xmpp/saslcookiemechanism.h
40,41c40,55
<   SaslCookieMechanism(const std::string & mechanism, const std::string & username, const std::string & cookie) :
<     mechanism_(mechanism), username_(username), cookie_(cookie) {}
---
>   SaslCookieMechanism(const std::string & mechanism,
>                       const std::string & username,
>                       const std::string & cookie,
>                       const std::string & token_service)
>     : mechanism_(mechanism),
>       username_(username),
>       cookie_(cookie),
>       token_service_(token_service) {}
> 
>   SaslCookieMechanism(const std::string & mechanism,
>                       const std::string & username,
>                       const std::string & cookie)
>     : mechanism_(mechanism),
>       username_(username),
>       cookie_(cookie),
>       token_service_("") {}
48a63,67
>     if (!token_service_.empty()) {
>       el->AddAttr(
>           QName(true, "http://www.google.com/talk/protocol/auth", "service"),
>           token_service_);
>     }
62a82
>   std::string token_service_;
diff -r libjingle-0.4.0/talk/xmpp/saslhandler.h libjingle/files/talk/xmpp/saslhandler.h
31a32
> #include <vector>
diff -r libjingle-0.4.0/talk/xmpp/xmppclient.h libjingle/files/talk/xmpp/xmppclient.h
141c141
<   std::string XmppClient::GetStateName(int state) const {
---
>   std::string GetStateName(int state) const {
diff -r libjingle-0.4.0/talk/xmpp/xmppclientsettings.h libjingle/files/talk/xmpp/xmppclientsettings.h
59a60,62
>   void set_token_service(const std::string & token_service) {
>     token_service_ = token_service;
>   }
75a79
>   const std::string & token_service() const { return token_service_; }
93a98
>   std::string token_service_;
diff -r libjingle-0.4.0/talk/xmpp/xmpplogintask.cc libjingle/files/talk/xmpp/xmpplogintask.cc
218a219,221
>         auth->SetAttr(QN_GOOGLE_ALLOW_NON_GOOGLE_ID_XMPP_LOGIN, "true");
>         auth->SetAttr(QN_GOOGLE_AUTH_CLIENT_USES_FULL_BIND_RESULT, "true");
> 
