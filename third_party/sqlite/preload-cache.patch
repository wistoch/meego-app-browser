diff --git a/third_party/sqlite/src/src/build.c b/third_party/sqlite/src/src/build.c
index 2cfb1f4..c9eed5e 100644
--- a/third_party/sqlite/src/src/build.c
+++ b/third_party/sqlite/src/src/build.c
@@ -24,6 +24,9 @@
 */
 #include "sqliteInt.h"
 
+#include "pager.h"
+#include "btree.h"
+
 /*
 ** This routine is called when a new SQL statement is beginning to
 ** be parsed.  Initialize the pParse structure as needed.
@@ -3688,3 +3691,30 @@ KeyInfo *sqlite3IndexKeyinfo(Parse *pParse, Index *pIdx){
   }
   return pKey;
 }
+
+/* Begin preload-cache.patch for Chromium */
+/* See declaration in sqlite3.h for information */
+int sqlite3Preload(sqlite3 *db)
+{
+  Pager *pPager;
+  Btree *pBt;
+  int rc;
+  int i;
+  int dbsLoaded = 0;
+
+  for(i=0; i<db->nDb; i++) {
+    pBt = db->aDb[i].pBt;
+    if( !pBt )
+      continue;
+    pPager = sqlite3BtreePager(pBt);
+    if( pPager ) {
+      rc = sqlite3PagerLoadall(pPager);
+      if (rc == SQLITE_OK)
+        dbsLoaded++;
+    }
+  }
+  if (dbsLoaded == 0)
+    return SQLITE_ERROR;
+  return SQLITE_OK;
+}
+/* End preload-cache.patch for Chromium */
diff --git a/third_party/sqlite/src/src/pager.c b/third_party/sqlite/src/src/pager.c
index 2faeb15..ba88923 100644
--- a/third_party/sqlite/src/src/pager.c
+++ b/third_party/sqlite/src/src/pager.c
@@ -790,6 +790,16 @@ static int pagerUseWal(Pager *pPager){
 # define pagerBeginReadTransaction(z) SQLITE_OK
 #endif
 
+/* Begin preload-cache.patch for Chromium */
+/* See comments above the definition. */
+int sqlite3PagerAcquire2(
+  Pager *pPager,
+  Pgno pgno,
+  DbPage **ppPage,
+  int noContent,
+  unsigned char *pDataToFill);
+/* End preload-cache.patch for Chromium */
+
 #ifndef NDEBUG 
 /*
 ** Usage:
@@ -4869,6 +4879,25 @@ int sqlite3PagerAcquire(
   DbPage **ppPage,    /* Write a pointer to the page here */
   int noContent       /* Do not bother reading content from disk if true */
 ){
+  /* This just passes through to our modified version with NULL data. */
+  return sqlite3PagerAcquire2(pPager, pgno, ppPage, noContent, 0);
+}
+
+/*
+** This is an internal version of sqlite3PagerAcquire that takes an extra
+** parameter of data to use to fill the page with. This allows more efficient
+** filling for preloaded data. If this extra parameter is NULL, we'll go to
+** the file.
+**
+** See sqlite3PagerLoadall which uses this function.
+*/
+int sqlite3PagerAcquire2(
+  Pager *pPager,      /* The pager open on the database file */
+  Pgno pgno,          /* Page number to fetch */
+  DbPage **ppPage,    /* Write a pointer to the page here */
+  int noContent,      /* Do not bother reading content from disk if true */
+  unsigned char* pDataToFill
+){
   int rc;
   PgHdr *pPg;
 
@@ -4944,9 +4973,17 @@ int sqlite3PagerAcquire(
       IOTRACE(("ZERO %p %d\n", pPager, pgno));
     }else{
       assert( pPg->pPager==pPager );
-      rc = readDbPage(pPg);
-      if( rc!=SQLITE_OK ){
-        goto pager_acquire_err;
+      if( pDataToFill ){
+        /* Just copy from the given memory */
+        memcpy(pPg->pData, pDataToFill, pPager->pageSize);
+        CODEC1(pPager, pPg->pData, pPg->pgno, 3, rc = SQLITE_NOMEM;
+                                                 goto pager_acquire_err);
+      }else{
+        /* Load from disk (old regular sqlite code path) */
+        rc = readDbPage(pPg);
+        if( rc!=SQLITE_OK ){
+          goto pager_acquire_err;
+        }
       }
     }
     pager_set_pagehash(pPg);
@@ -6318,6 +6355,91 @@ int sqlite3PagerMovepage(Pager *pPager, DbPage *pPg, Pgno pgno, int isCommit){
 }
 #endif
 
+/* Begin preload-cache.patch for Chromium */
+/**
+** When making large allocations, there is no need to stress the heap and
+** potentially hold its lock while we allocate a bunch of memory.  If we know
+** the allocation will be large, go directly to the OS instead of the heap.
+**/
+static void* allocLarge(size_t size) {
+#if SQLITE_OS_WIN
+  return VirtualAlloc(NULL, size, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);
+#else
+  return sqlite3Malloc(size);
+#endif
+}
+
+static void freeLarge(void* ptr) {
+#if SQLITE_OS_WIN
+  VirtualFree(ptr, 0, MEM_RELEASE);
+#else
+  sqlite3_free(ptr);
+#endif
+}
+
+/**
+** Addition: This will attempt to populate the database cache with
+** the first N bytes of the file, where N is the total size of the cache.
+** Because we can load this as one chunk from the disk, this is much faster
+** than loading a subset of the pages one at a time in random order.
+**
+** The pager must be initialized before this function is called. This means a
+* statement must be open that has initialized the pager and is keeping the
+** cache in memory.
+**/
+int sqlite3PagerLoadall(Pager* pPager)
+{
+  int i;
+  int rc;
+  int nMax;
+  int loadSize;
+  int loadPages;
+  unsigned char *fileData;
+
+  if (pPager->dbSize < 0 || pPager->pageSize < 0) {
+    /* pager not initialized, this means a statement is not open */
+    return SQLITE_MISUSE;
+  }
+
+  /* compute sizes */
+  nMax = sqlite3PcacheGetCachesize(pPager->pPCache);
+  if (nMax < pPager->dbSize)
+    loadPages = nMax;
+  else
+    loadPages = pPager->dbSize;
+  loadSize = loadPages * pPager->pageSize;
+
+  /* load the file as one chunk */
+  fileData = allocLarge(loadSize);
+  if (! fileData)
+    return SQLITE_NOMEM;
+  rc = sqlite3OsRead(pPager->fd, fileData, loadSize, 0);
+  if (rc != SQLITE_OK) {
+    freeLarge(fileData);
+    return rc;
+  }
+
+  /* Copy the data to each page. Note that the page numbers we pass to _get
+   * are one-based, 0 is a marker for no page. We also need to check that we
+   * haven't loaded more pages than the cache can hold total. There may have
+   * already been a few pages loaded before, so we may fill the cache before
+   * loading all of the pages we want to.
+   */
+  for(i=1;
+      i <= loadPages && sqlite3PcachePagecount(pPager->pPCache) < nMax;
+      i++) {
+    DbPage *pPage = 0;
+    rc = sqlite3PagerAcquire2(pPager, i, &pPage, 0,
+                              &fileData[(i-1)*(i64)pPager->pageSize]);
+    if (rc != SQLITE_OK)
+      break;
+    sqlite3PagerUnref(pPage);
+  }
+  freeLarge(fileData);
+  return SQLITE_OK;
+}
+/* End preload-cache.patch for Chromium */
+
 /*
 ** Return a pointer to the data for the specified page.
 */
diff --git a/third_party/sqlite/src/src/pager.h b/third_party/sqlite/src/src/pager.h
index c12afa7..f451a47 100644
--- a/third_party/sqlite/src/src/pager.h
+++ b/third_party/sqlite/src/src/pager.h
@@ -153,6 +153,8 @@ const sqlite3_vfs *sqlite3PagerVfs(Pager*);
 sqlite3_file *sqlite3PagerFile(Pager*);
 const char *sqlite3PagerJournalname(Pager*);
 int sqlite3PagerNosync(Pager*);
+/* This function is for preload-cache.patch for Chromium: */
+int sqlite3PagerLoadall(Pager*);
 void *sqlite3PagerTempSpace(Pager*);
 int sqlite3PagerIsMemdb(Pager*);
 
diff --git a/third_party/sqlite/src/src/sqlite.h.in b/third_party/sqlite/src/src/sqlite.h.in
index 2bbd687..25012ad 100644
--- a/third_party/sqlite/src/src/sqlite.h.in
+++ b/third_party/sqlite/src/src/sqlite.h.in
@@ -4683,6 +4683,21 @@ int sqlite3_declare_vtab(sqlite3*, const char *zSQL);
 */
 int sqlite3_overload_function(sqlite3*, const char *zFuncName, int nArg);
 
+/* Begin preload-cache.patch for Chromium */
+/*
+** Preload the databases into the pager cache, up to the maximum size of the
+** pager cache.
+**
+** For a database to be loaded successfully, the pager must be active. That is,
+** there must be an open statement on that database. See sqlite3pager_loadall
+**
+** There might be many databases attached to the given connection. We iterate
+** them all and try to load them. If none are loadable successfully, we return
+** an error. Otherwise, we return OK.
+*/
+int sqlite3Preload(sqlite3 *db);
+/* End preload-cache.patch for Chromium */
+
 /*
 ** The interface to the virtual-table mechanism defined above (back up
 ** to a comment remarkably similar to this one) is currently considered
