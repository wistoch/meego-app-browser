<!DOCTYPE HTML>
<html>

<head>
  <title>Webkit Layout Test History</title>
  <script>
    var pageLoadStartTime = Date.now();
  </script>
  <style>
    body {
      font-family: arial;
      font-size: 13px;
    }
    h2 {
      font-size: 16px;
      margin-bottom: .25em;
    }
    #max-results-form {
      display: inline;
    }
    #max-results-input {
      width: 30px;
    }
    #tests-form {
      display: -webkit-box;
    }
    #tests-form > * {
      display: -webkit-box;
    }
    #tests-form > div {
      -webkit-box-flex: 0;
    }
    #tests-input {
      -webkit-box-flex: 1;
    }
    .test-link {
      white-space: normal;
    }
    .test-link, .options-container {
      padding: 0 2px;
    }
    .test-table {
      white-space: nowrap;
    }
    .test-table {
      width: 100%;
    }
    .test-table tr {
      border: 1px solid red;
      background-color: #E8E8E8;
    }
    .test-table tbody tr:hover {
      opacity: .7;
    }
    .test-table th {
      -webkit-user-select: none;
      -moz-user-select: none;
    }
    .link, .sortable .header-text {
      color: blue;
      text-decoration: underline;
      cursor: pointer;
    }
    .table-header-content,
    .table-header-content * {
      display: -webkit-box;
    }
    .table-header-content * {
      -webkit-box-flex: 1;
      cursor: pointer;
      white-space: normal;
    }
    .results {
      cursor: pointer;
      padding: 0;
      font-size: 10px;
      text-align: center;
    }
    #legend {
      position: fixed;
      top: 5px;
      right: 5px;
      width: 130px;
      border: 2px solid grey;
      background-color: white;
    }
    #legend * {
      margin: 3px;
      padding: 0 2px;
    }
    body > div > :not(#legend) {
      margin-right: 145px;
    }
    #builders * {
      margin: 0 5px;
      display: inline-block;
      white-space: nowrap;
    }
    .test-table .wrong-expectations,
    .wrong-expectations {
      background-color: #afdaff;
    }
    .P {
      background-color: #8fdf5f;
    }
    .N {
      background-color: #e0b0ff;
    }
    .C {
      background-color: #ffc343;
    }
    .T {
      background-color: #fffc6c;
    }
    .I {
      background-color: #96f;
    }
    .S {
      background-color: #c6c;
    }
    .F {
      background-color: #e98080;
    }
    .O {
      background-color: #69f;
    }
    .separator {
      border: 1px solid lightgray;
      height: 0px;
    }
    .different-platform {
      color: gray;
      font-size: 10px;
    }
    .current-builder {
      font-weight: bold;
    }
    #passing-tests {
      -webkit-column-count: 2;
      -webkit-column-gap: 25px;
      -webkit-column-rule: 1px dashed black;
      -moz-column-count: 2;
      -moz-column-gap: 25px;
      -moz-column-rule: 1px dashed black;
    }
    .not-found {
      color: red;
      font-size: large;
    }
    #loading-ui {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      background-color: yellow;
      padding: 5px;
      text-align: center;
      font-weight: bold;
    }
  </style>

  <script>
  /**
   * @fileoverview Creates a dashboard for multiple runs of a given set of tests
   * on the buildbots. Pulls in JSONP-ish files with the results for running
   * tests on a given builder (i.e. ADD_RESULTS(json_here)) and the expectations
   * for all tests on all builders (i.e. ADD_EXPECTATIONS(json_here)).
   *
   * This shows flakiness of the tests as well as runtimes for slow tests.
   *
   * Also, each column in the dashboard is sortable.
   *
   * Currently, only webkit tests are supported, but adding other test types
   * should just require the following steps:
   *   -generate results.json and expectations.json for these tests
   *   -copy them to the appropriate location
   *   -add the builder name to the list of builders below.
   */

   // CONSTANTS
   var FORWARD = 'forward';
   var BACKWARD = 'backward';
   var TEST_URL_BASE_PATH =
       'http://trac.webkit.org/projects/webkit/browser/trunk/';
   var BUILDERS_BASE_PATH =
       'http://build.chromium.org/buildbot/waterfall/builders/';
   var EXPECTATIONS_MAP = {
     'T': 'TIMEOUT',
     'C': 'CRASH',
     'P': 'PASS',
     'F': 'TEXT FAIL',
     'S': 'SIMPLIFIED',
     'I': 'IMAGE',
     'O': 'OTHER',
     'N': 'NO DATA'
   };
   var PLATFORMS = {'MAC': 'MAC', 'LINUX': 'LINUX', 'WIN': 'WIN'};
   var BUILD_TYPES = {'DEBUG': 'DBG', 'RELEASE': 'RELEASE'};

   // GLOBALS
   // The DUMMYVALUE gets shifted off the array in the first call to
   // generatePage.
   var tableHeaders = ['DUMMYVALUE', 'bugs', 'modifiers', 'expectations',
       'missing', 'extra', 'slowest run',
       'flakiness (numbers are runtimes in seconds)'];
   var perBuilderPlatformAndBuildType = {};
   var perBuilderFailures = {};
   // Map of builder to arrays of tests that are listed in the expectations file
   // but have for that builder.
   var perBuilderWithExpectationsButNoFailures = {};


  // Generic utility functions.
  function $(id) {
    return document.getElementById(id);
  }

  function stringContains(a, b) {
    return a.indexOf(b) != -1;
  }

  function isValidName(str) {
    return str.match(/[A-Za-z0-9\-\_,]/);
  }

  function trimString(str) {
    return str.replace(/^\s+|\s+$/g, '');
  }

  function anyKeyInString(object, string) {
    for (var key in object) {
      if (stringContains(string, key))
        return true;
    }
    return false;
  }

  function validateParameter(state, key, value, validateFn) {
    if (validateFn()) {
      state[key] = value;
    } else {
      console.log(key + ' value is not valid: ' + value);
    }
  }

  /**
   * Parses a string (e.g. window.location.hash) and calls
   * validValueHandler(key, value) for each key-value pair in the string.
   */
  function parseParameters(parameterStr, validValueHandler) {
    var params = parameterStr.split('&');
    for (var i = 0; i < params.length; i++) {
      var thisParam = params[i].split('=');
      if (thisParam.length != 2) {
        console.log('Invalid query parameter: ' + params[i]);
        continue;
      }

      var key = thisParam[0];
      var value = decodeURIComponent(thisParam[1]);
      if (!validValueHandler(key, value))
        console.log('Invalid key: ' + key + ' value: ' + value);
    }
  }

  function appendScript(path) {
    var script = document.createElement('script');
    script.src = path;
    document.getElementsByTagName('head')[0].appendChild(script);
  }

  // Parse hash parameters.
  // Permalinkable state of the page.
  var currentState = {};

  if (stringContains(window.location.hash, "debug=true")) {
    // In debug mode point to the results.json and expectations.json in the
    // local tree. Useful for debugging changes to the python JSON generator.
    var builders = {'DUMMY_BUILDER_NAME': ''};
    var builderBase = '../../Debug/';
    currentState['testType'] = 'layout-test-results';
  } else {
    // Map of builderName (the name shown in the waterfall)
    // to builderPath (the path used in the builder's URL)
    // TODO(ojan): Make this switch based off of the testType.
    var builders = {
      'Webkit': 'webkit-rel',
      'Webkit (dbg)(1)': 'webkit-dbg-1',
      'Webkit (dbg)(2)': 'webkit-dbg-2',
      'Webkit (dbg)(3)': 'webkit-dbg-3',
      'Webkit Linux': 'webkit-rel-linux',
      'Webkit Linux (dbg)(1)': 'webkit-dbg-linux-1',
      'Webkit Linux (dbg)(2)': 'webkit-dbg-linux-2',
      'Webkit Linux (dbg)(3)': 'webkit-dbg-linux-3',
      'Webkit Mac10.5': 'webkit-rel-mac5',
      'Webkit Mac10.5 (dbg)(1)': 'webkit-dbg-mac5-1',
      'Webkit Mac10.5 (dbg)(2)': 'webkit-dbg-mac5-2',
      'Webkit Mac10.5 (dbg)(3)': 'webkit-dbg-mac5-3'
    };
    var builderBase = 'http://build.chromium.org/buildbot/';
  }

  var defaultStateValues = {
    sortOrder: BACKWARD,
    sortColumn: 'flakiness',
    showWontFix: false,
    showCorrectExpectations: false,
    showFlaky: true,
    maxResults: 200,
    testType: 'layout_test_results'
  };

  for (var builder in builders) {
    defaultStateValues.builder = builder;
    break;
  }

  function fillDefaultStateValues() {
    // tests has no states with default values.
    if (currentState.tests)
      return;

    for (var state in defaultStateValues) {
      if (!(state in currentState))
        currentState[state] = defaultStateValues[state];
    }
  }

  function handleValidHashParameter(key, value) {
    switch(key) {
      case 'testType':
        validateParameter(currentState, key, value,
            function() {
              return isValidName(value);
            });

        return true;

      case 'tests':
        validateParameter(currentState, key, value,
            function() {
              return isValidName(value);
            });

        return true;

      case 'builder':
        validateParameter(currentState, key, value,
            function() {
              return value in builders;
            });

        return true;

      case 'sortColumn':
        validateParameter(currentState, key, value,
            function() {
              for (var i = 0; i < tableHeaders.length; i++) {
                if (value == getSortColumnFromTableHeader(tableHeaders[i]))
                  return true;
              }
              return value == 'test';
            });

        return true;

      case 'sortOrder':
        validateParameter(currentState, key, value,
            function() {
              return value == FORWARD || value == BACKWARD;
            });

        return true;

      case 'maxResults':
        validateParameter(currentState, key, value,
            function() {
              return value.match(/^\d+$/)
            });

        return true;

      case 'debug':
      case 'showWontFix':
      case 'showCorrectExpectations':
      case 'showFlaky':
        currentState[key] = value == 'true';

        return true;

      default:
        return false;
    }
  }

  // Keep the location around for detecting changes to hash arguments
  // manually typed into the URL bar.
  var oldLocation;

  function parseAllParameters() {
    oldLocation = window.location.href;
    parseParameters(window.location.hash.substring(1),
        handleValidHashParameter);
    fillDefaultStateValues();
  }

  parseAllParameters();

  // Append JSON script elements.
  var resultsByBuilder = {};
  // Maps test path to an array of {builder, testResults} objects.
  var testToResultsMap = {};
  var expectationsByTest = {};
  function ADD_RESULTS(builds) {
    for (var builderName in builds) {
      if (builderName != 'version')
        resultsByBuilder[builderName] = builds[builderName];
    }

    generatePage();
  }

  function getPathToBuilderResultsFile(builderName) {
    return builderBase + currentState['testType'] + '/' +
        builders[builderName] + '/';
  }

  for (var builderName in builders) {
    appendScript(getPathToBuilderResultsFile(builderName) + 'results.json');
  }

  // Grab expectations file from any builder.
  appendScript(getPathToBuilderResultsFile(builderName) + 'expectations.json');

  var expectationsLoaded = false;
  function ADD_EXPECTATIONS(expectations) {
    expectationsLoaded = true;
    expectationsByTest = expectations;
    generatePage();
  }


  function createResultsObjectForTest(test) {
    return {
      test: test,
      // HTML for display of the results in the flakiness column
      html: '',
      flips: 0,
      slowestTime: 0,
      meetsExpectations: true,
      isWontFix: false,
      // Sorted string of missing expectations
      missing: '',
      // String of extra expectations (i.e. expectations that never occur).
      extra: '',
      // HTML for bug IDs for this test for all platforms
      bugsHTML: '',
      // HTML for expectations for this test for all platforms
      expectationsHTML: '',
      // HTML for modifiers for this test for all platforms
      modifiersHTML: '',
      rawResults: ''
    };
  }

  function getMatchingElement(stringToMatch, elementsMap) {
    for (var element in elementsMap) {
      if (stringContains(stringToMatch, elementsMap[element]))
        return element;
    }
  }

  /**
   * Returns whether the given string of modifiers applies to the platform and
   * build type of the given builder.
   */
  function hasPlatformAndBuildType(builderName, modifiers) {
    var platformAndBuildType = getPlatFormAndBuildType(builderName);
    var hasThisPlatform = stringContains(modifiers,
        platformAndBuildType.platform);
    var hasThisBuildType = stringContains(modifiers,
        platformAndBuildType.buildType);

    var hasAnyPlatform = anyKeyInString(PLATFORMS, modifiers);
    var hasAnyBuildType = anyKeyInString(BUILD_TYPES, modifiers);

    return (!hasAnyBuildType || hasThisBuildType) &&
        (!hasAnyPlatform || hasThisPlatform);
  }

  function getPlatFormAndBuildType(builderName) {
    if (!perBuilderPlatformAndBuildType[builderName]) {
      // If the build name does not contain a platform
      // or build type, assume Windows Release.
      var currentBuildUppercase = builderName.toUpperCase();
      var platform = getMatchingElement(currentBuildUppercase, PLATFORMS) ||
          'WIN';
      var buildType = getMatchingElement(currentBuildUppercase, BUILD_TYPES) ||
          'RELEASE';
      perBuilderPlatformAndBuildType[builderName] = {platform: platform,
          buildType: buildType};
    }
    return perBuilderPlatformAndBuildType[builderName];
  }

  /**
   * Returns whether any of the modifiers in the array have the correct
   * platform and build type for the given builder.
   */
  function getModifierThatHasPlatformAndBuildType(builderName, modifiersArray) {
    for (var i = 0; i < modifiersArray.length; i++) {
      if (hasPlatformAndBuildType(builderName, modifiersArray[i].modifiers))
        return modifiersArray[i];
    }
    return null;
  }

  /**
   * Returns the expectation string for the given single character result.
   * This string should match the expectations that are put into
   * test_expectations.py.
   *
   * For example, if we start explicitly listing IMAGE result failures,
   * this function should start returning 'IMAGE'.
   */
  function getExpectationsFileStringForResult(result) {
    // For the purposes of comparing against the expecations of a test,
    // consider image/simplified diff failures as just failures since
    // the test_expectations file doesn't treat them specially.
    if (result == 'F' || result == 'S' || result == 'I')
      return 'FAIL';

    if (result == 'N' || result == 'O')
      return '';

    return EXPECTATIONS_MAP[result];
  }

  // Map of all tests to true values. This is just so we can have the list of
  // all tests across all the builders.
  var allTests;

  /**
   * Returns a map of all tests to true values. This is just so we can have the
   * list of all tests across all the builders.
   */
  function getAllTests() {
    if (!allTests) {
      allTests = {};
      for (var builder in builders) {
        addTestsForBuilder(builder, allTests);
      }
    }
    return allTests;
  }

  /**
   * Adds all the tests for the given builder to the testMapToPopulate.
   */
  function addTestsForBuilder(builder, testMapToPopulate) {
    var tests = resultsByBuilder[builder].tests;
    for (var test in tests) {
      testMapToPopulate[test] = true;
    }
  }

  // Map of all tests to true values by platform and build type.
  // e.g. allTestsByPlatformAndBuildType['WIN']['DEBUG'] will have the union
  // of all tests run on the win-debug builders.
  var allTestsByPlatformAndBuildType = {};
  for (var platform in PLATFORMS) {
    allTestsByPlatformAndBuildType[platform] = {};
  }

  /**
   * Map of all tests to true values by platform and build type.
   * e.g. allTestsByPlatformAndBuildType['WIN']['DEBUG'] will have the union
   * of all tests run on the win-debug builders.
   */
  function getAllTestsWithSamePlatformAndBuildType(builder) {
    var buildInfo = getPlatFormAndBuildType(builder);
    var platform = buildInfo.platform;
    var buildType = buildInfo.buildType;

    if (!allTestsByPlatformAndBuildType[platform][buildType]) {
      var tests = {};
      for (var thisBuilder in builders) {
        var thisBuilderBuildInfo = getPlatFormAndBuildType(thisBuilder);
        if (thisBuilderBuildInfo.buildType == buildType &&
            thisBuilderBuildInfo.platform == platform) {
          addTestsForBuilder(thisBuilder, tests);
        }
      }
      allTestsByPlatformAndBuildType[platform][buildType] = tests;
    }

    return allTestsByPlatformAndBuildType[platform][buildType];
  }

  /**
   * Adds the given test and path to the appropriate objects depending on
   * whether the modifiers match the builders platform and buildType.
   */
  function addTestAndExpectations(test, prefixPath, builder, expectationsMap,
      expectations, testPrefixes) {
    var modifiersForBuilder =
        getModifierThatHasPlatformAndBuildType(builder, expectations);
    if (modifiersForBuilder) {
      if (getAllTestsWithSamePlatformAndBuildType(builder)[test]) {
        expectationsMap[test] = expectations;
        testPrefixes[test] = prefixPath;
      } else if (!stringContains(modifiersForBuilder.modifiers, 'SKIP') &&
          !modifiersForBuilder.expectations.match(/^\s*PASS\s*$/)) {
        // Don't include skip tests here as they'll look the same as a test
        // that passes on all builders.
        // Also don't include tests that are only expected to pass, e.g.
        // SLOW : foo/bar/baz.html = PASS
        // TODO(ojan): Should we also exclude WONTFIX tests here?
        perBuilderWithExpectationsButNoFailures[builder].push(test);
      }
      return true;
    }
    return false;
  }

  /**
   * Naive check that path points to a directory.
   */
  function isDirectory(path) {
    return !stringContains(path, '.')
  }

  function addHTMLToIndividualOptionsArray(array, html, isCurrentPlatform) {
    if (html) {
      array.push('<div class="option' +
          (isCurrentPlatform ? '' : ' different-platform') + '">' + html +
          '</div>');
    }
  }

  function addHtmlToOptionsArrays(htmlArrays, expectations, modifiers, bugs,
      isCurrentPlatform) {
    addHTMLToIndividualOptionsArray(htmlArrays.expectations, expectations,
        isCurrentPlatform);
    addHTMLToIndividualOptionsArray(htmlArrays.modifiers, modifiers,
        isCurrentPlatform);
    addHTMLToIndividualOptionsArray(htmlArrays.bugs, getHtmlForBugs(bugs),
        isCurrentPlatform);
  }

  function processTestRunsForBuilder(builderName) {
    if (perBuilderFailures[builderName])
      return;

    var start = Date.now();

    var failures = [];
    var allTests = getAllTests();

    var expectationsMap = {};
    for (var test in allTests) {
      if (expectationsByTest[test])
        expectationsMap[test] = expectationsByTest[test];
    }

    var testPrefixes = {};
    perBuilderWithExpectationsButNoFailures[builderName] = [];
    for (var path in expectationsByTest) {
      var expectations = expectationsByTest[path];
      if (!isDirectory(path) &&
          addTestAndExpectations(path, path, builderName, expectationsMap,
              expectations, testPrefixes)) {
        continue;
      }
      // Test path doesn't match a specific test, see if it prefix matches
      // any test.
      for (var test in allTests) {
        if (stringContains(test, path) &&
            (!testPrefixes[test] ||
             !stringContains(testPrefixes[test], path))) {
          addTestAndExpectations(test, path, builderName, expectationsMap,
              expectations, testPrefixes);
        }
      }
    }
    perBuilderWithExpectationsButNoFailures[builderName].sort();

    var allTestsForThisBuilder = resultsByBuilder[builderName].tests;
    for (var test in allTestsForThisBuilder) {
      var resultsForTest = createResultsObjectForTest(test);

      if (expectationsMap[test] && expectationsMap[test].length) {
        var expectationsArray = expectationsMap[test];
        var htmlArrays = {};
        htmlArrays.expectations = [];
        htmlArrays.modifiers = [];
        htmlArrays.bugs = [];

        var thisBuilderExpectations;
        var thisBuilderModifiers;
        for (var i = 0; i < expectationsArray.length; i++) {
          var modifiers = expectationsArray[i].modifiers;
          var bugs = modifiers.match(/BUG\d+/g);
          if (bugs) {
            for (var j = 0; j < bugs.length; j++) {
              modifiers = modifiers.replace(bugs[j], '');
            }
            modifiers = trimString(modifiers);
            bugs = bugs.join(' ');
          } else {
            bugs = '';
          }

          var expectations = expectationsArray[i].expectations;
          if (hasPlatformAndBuildType(builderName, modifiers)) {
            resultsForTest.bugs = bugs;
            resultsForTest.expectations = expectations;
            resultsForTest.modifiers = modifiers;
            // TODO(ojan): Also specially mark slow tests that should be marked
            // as slow or should have the slow modifier removed.
            resultsForTest.isWontFix = stringContains(modifiers, 'WONTFIX');
          } else {
            addHtmlToOptionsArrays(htmlArrays, expectations, modifiers, bugs,
                false);
          }
        }

        if (resultsForTest.expectations) {
          addHtmlToOptionsArrays(htmlArrays, resultsForTest.expectations,
              resultsForTest.modifiers, resultsForTest.bugs, true);
        }

        resultsForTest.bugsHTML +=
            htmlArrays.bugs.join('<div class=separator></div>');
        resultsForTest.expectationsHTML +=
            htmlArrays.expectations.join('<div class=separator></div>');
        resultsForTest.modifiersHTML +=
            htmlArrays.modifiers.join('<div class=separator></div>');
      }

      var rawTest = resultsByBuilder[builderName].tests[test];
      resultsForTest.rawTimes = rawTest.times;
      var rawResults = rawTest.results;
      resultsForTest.rawResults = rawResults;
      resultsForTest.flips = rawResults.length - 1;

      var unexpectedExpectations = [];
      var resultsMap = {}
      for (var i = 0; i < rawResults.length; i++) {
        var expectation = getExpectationsFileStringForResult(rawResults[i][1]);
        resultsMap[expectation] = true;
      }

      var expectationsArray = resultsForTest.expectations ?
          resultsForTest.expectations.split(' ') : [];
      var extraExpectations = expectationsArray.filter(
          function(element) {
              return element && !resultsMap[element] &&
                  !stringContains(element, 'BUG');
          });

      var missingExpectations = [];
      for (var result in resultsMap) {
        var hasExpectation = false;
        for (var i = 0; i < expectationsArray.length; i++) {
          if (result == expectationsArray[i])
            hasExpectation = true;
        }
        if (!hasExpectation)
          missingExpectations.push(result);
      }

      var times = resultsByBuilder[builderName].tests[test].times;
      for (var i = 0; i < times.length; i++) {
        resultsForTest.slowestTime = Math.max(resultsForTest.slowestTime,
            times[i][1]);
      }

      if (resultsForTest.slowestTime &&
          (!resultsForTest.expectations ||
           !stringContains(resultsForTest.expectations, 'TIMEOUT')) &&
          (!resultsForTest.modifiers ||
           !stringContains(resultsForTest.modifiers, 'SLOW'))) {
        missingExpectations.push('SLOW');
      }

      resultsForTest.meetsExpectations =
          !missingExpectations.length && !extraExpectations.length;
      resultsForTest.missing = missingExpectations.sort().join(' ');
      resultsForTest.extra = extraExpectations.sort().join(' ');

      failures.push(resultsForTest);

      if (!testToResultsMap[test])
        testToResultsMap[test] = [];
      testToResultsMap[test].push(
          {builder: builderName, results: resultsForTest});
    }

    perBuilderFailures[builderName] = failures;
    logTime('processTestRunsForBuilder: ' + builderName, start);
  }

  function hasExpectations(expectations, resultName) {
    if (resultName == 'NO DATA')
      return true;

    if (!expectations)
      return false;

    return stringContains(expectations, resultName);
  }

  var bugUrlPrefix = '<a href="http://';
  var bugUrlPostfix = '/$1">$1</a> ';
  var internalBugReplaceValue = bugUrlPrefix + 'b' + bugUrlPostfix;
  var externalBugReplaceValue = bugUrlPrefix + 'crbug.com' + bugUrlPostfix;

  /**
   * Returns the BUG modifiers linking to the bug.
   * Bugs with 4 or 5 digits are crbug.com bugs. Bugs with 6 or 7 digits
   * are internal google bugs.
   */
  function getHtmlForBugs(bugs) {
    bugs = bugs.replace(/BUG(\d{4})(\ |$)/g, externalBugReplaceValue);
    bugs = bugs.replace(/BUG(\d{5})(\ |$)/g, externalBugReplaceValue);
    bugs = bugs.replace(/BUG(\d{6})(\ |$)/g, internalBugReplaceValue);
    bugs = bugs.replace(/BUG(\d{7})(\ |$)/g, internalBugReplaceValue);
    return bugs;
  }

  function loadBuilderPageForBuildNumber(builderName, buildNumber) {
    window.open(BUILDERS_BASE_PATH + builderName + '/builds/' + buildNumber);
  }

  function getHtmlForTestResults(test, builder) {
    var html = '';
    var results = test.rawResults.concat();
    var times = test.rawTimes.concat();
    var buildNumbers = resultsByBuilder[builder].buildNumbers;

    var indexToReplaceCurrentResult = -1;
    var indexToReplaceCurrentTime = -1;
    var currentResultArray, currentTimeArray, currentResult, innerHTML;
    for (var i = 0;
         i < buildNumbers.length && i < currentState.maxResults;
         i++) {
      if (i > indexToReplaceCurrentResult) {
        currentResultArray = results.shift();
        if (currentResultArray) {
          currentResult = currentResultArray[1];
          indexToReplaceCurrentResult += currentResultArray[0];
        } else {
          currentResult = 'N';
          indexToReplaceCurrentResult += buildNumbers.length;
        }
      }

      if (i > indexToReplaceCurrentTime) {
        currentTimeArray = times.shift();
        var currentTime = 0;
        if (currentResultArray) {
          currentTime = currentTimeArray[1];
          indexToReplaceCurrentTime += currentTimeArray[0];
        } else {
          indexToReplaceCurrentTime += buildNumbers.length;
        }
        innerHTML = currentTime || '&nbsp;';
      }

      var buildNumber = buildNumbers[i];
      html += '<td title="Build:' + buildNumber + '" class="results ' +
          currentResult + '" onclick=\'loadBuilderPageForBuildNumber("' +
          builder + '","' + buildNumber + '")\'>' + innerHTML + '</td>';
    }
    return html;
  }

  function getHTMLForTestsWithExpectationsButNoFailures(builder) {
    var tests = perBuilderWithExpectationsButNoFailures[builder];
    if (!tests.length)
      return '';

    var buildInfo = getPlatFormAndBuildType(builder);
    return '<h2>Have expectations for ' + buildInfo.platform + '-' +
          buildInfo.buildType + ' but have not failed in last ' +
          resultsByBuilder[builderName].buildNumbers.length +
          ' runs.</h2><div id="passing-tests"><div>' +
          tests.join('</div><div>') + '</div></div>';
  }

  /**
   * Returns true if a test should be considered flaky. Uses heuristics to
   * avoid common non-flaky cases.
   */
  function isTestFlaky(testResult) {
    return testResult.flips > 1 && !isFixedTest(testResult);
  }

  /**
   * Returns whether this tests results match the heuristic for new tests that
   * have been fixed. Specifically, a new test that fails a couple
   * times and then passes from then on would have results like PPPPFFFFNNNNN.
   * Where that middle part can be a series of F's, S's or I's for the
   * different types of failures.
   */
  function isFixedTest(testResult) {
    if (testResult.isFixedTest === undefined) {
      var results = testResult.rawResults;
      var isFixedTest = results[0][1] == 'P';
      if (isFixedTest && results.length > 1) {
        var secondResult = results[1][1];
        isFixedTest = secondResult == 'S' || secondResult == 'F' ||
            secondResult == 'I';
      }
      if (isFixedTest && results.length > 2) {
        isFixedTest = results.length == 3 && results[2][1] == 'N';
      }
      testResult.isFixedTest = isFixedTest;
    }
    return testResult.isFixedTest;
  }

  /**
   * Returns whether we should exclude test results from the test table.
   * Note that we never want to exclude tests when we're in the individual
   * tests view of the dashboard since the user is explicitly listing tests
   * to view.
   */
  function shouldHideTest(testResult) {
    if (currentState.tests)
      return false;

    if (testResult.isWontFix && !currentState.showWontFix)
      return true;

    if ((testResult.meetsExpectations || isFixedTest(testResult)) &&
        !currentState.showCorrectExpectations) {
      // Only hide flaky tests that match their expectations if showFlaky
      // is false.
      return !currentState.showFlaky || !isTestFlaky(testResult);
    }

    return !currentState.showFlaky && isTestFlaky(testResult);
  }

  function getHTMLForSingleTestRow(test, builder, opt_isCrossBuilderView) {
    if (shouldHideTest(test)) {
      // The innerHTML call is considerably faster if we exclude the rows for
      // items we're not showing than if we hide them using display:none.
      return '';
    }

    // If opt_isCrossBuilderView is true, we're just viewing a single test
    // with results for many builders, so the first column is builder names
    // instead of test paths.
    var testCellHTML = opt_isCrossBuilderView ? builder :
      '<span class="link" onclick="setState(\'tests\', \'' + test.test +
      '\');return false;">' + test.test + '</span>';

    return '<tr class="' +
      (test.meetsExpectations ? '' : 'wrong-expectations') +
      // TODO(ojan): If a test is a chrome/ or a pending/ test, point to
      // src.chromium.org instead of trac.webkit.org.
      '"><td class=test-link>' + testCellHTML +
      '</td><td class=options-container>' + test.bugsHTML +
      '</td><td class=options-container>' + test.modifiersHTML +
      '</td><td class=options-container>' + test.expectationsHTML +
      '</td><td>' + test.missing +
      '</td><td>' + test.extra +
      '</td><td>' + (test.slowestTime ? test.slowestTime + 's' : '') +
      '</td>' + getHtmlForTestResults(test, builder) + '</tr>';
  }

  function getSortColumnFromTableHeader(headerText) {
    return headerText.split(' ', 1)[0];
  }

  function getHTMLForTestTable(rowsHTML) {
    var html = '<table class=test-table><thead><tr>';
    for (var i = 0; i < tableHeaders.length; i++) {
      // Use the first word of the header title as the sortkey
      var thisSortValue = getSortColumnFromTableHeader(tableHeaders[i]);
      var arrowHTML = thisSortValue == currentState.sortColumn ?
          '<span class=' + currentState.sortOrder + '>' +
          (currentState.sortOrder == FORWARD ? '&uarr;' : '&darr;' ) +
          '</span>' :
          '';
      html += '<th sortValue=' + thisSortValue +
          // Extend last th through all the rest of the columns.
          (i == tableHeaders.length - 1 ? ' colspan=10000' : '') +
          // Extra span here is so flex boxing actually centers.
          // There's probably a better way to do this with CSS only though.
          '><div class=table-header-content><span></span>' + arrowHTML +
          '<span class=header-text>' + tableHeaders[i] + '</span>' +
          arrowHTML + '</div></th>';
    }
    return html + '</tr></thead><tbody>' + rowsHTML + '</tbody></table>';
  }

  function setFullPageHTML(html) {
    var startTime = Date.now();
    // InnerHTML to a div that's not in the document. This is
    // ~300ms faster in Safari 4 and Chrome 4 on mac.
    var div = document.createElement('div');
    div.innerHTML = html;
    document.body.innerHTML = '';
    document.body.appendChild(div);
    logTime('Time to innerHTML', startTime);
  }

  function getAlphanumericCompare(column, reverse) {
    return getReversibleCompareFunction(function(a, b) {
      // Put null entries at the bottom
      var a = a[column] ? String(a[column]) : 'z';
      var b = b[column] ? String(b[column]) : 'z';

      if (a < b)
        return -1;
      else if (a == b)
        return 0;
      else
        return 1;
    }, reverse);
  }

  function getNumericSort(column, reverse) {
    return getReversibleCompareFunction(function(a, b) {
      a = parseFloat(a[column]);
      b = parseFloat(b[column]);
      return a - b;
    }, reverse);
  }

  function getReversibleCompareFunction(compare, reverse) {
    return function(a, b) {
      return compare(reverse ? b : a, reverse ? a : b);
    }
  }

  function changeSort(e) {
    var target = e.currentTarget;
    e.preventDefault();

    var sortValue = target.getAttribute('sortValue');
    while (target && target.tagName != 'TABLE') {
      target = target.parentNode;
    }

    var sort = 'sortColumn';
    var orderKey = 'sortOrder';
    if (sortValue == currentState[sort] && currentState[orderKey] == FORWARD)
      order = BACKWARD;
    else
      order = FORWARD;

    setState(sort, sortValue, orderKey, order);
  }

  function sortTests(tests, column, order) {
    var resultsProperty, sortFunctionGetter;
    if (column == 'flakiness') {
      sortFunctionGetter = getNumericSort;
      resultsProperty = 'flips';
    } else if (column == 'slowest') {
      sortFunctionGetter = getNumericSort;
      resultsProperty = 'slowestTime';
    } else {
      sortFunctionGetter = getAlphanumericCompare;
      resultsProperty = column;
    }

    tests.sort(sortFunctionGetter(resultsProperty, order == BACKWARD));
  }

  function generatePage() {
    // Only continue if all the JSON files have loaded.
    if (!expectationsLoaded)
      return;

    for (var build in builders) {
      if (!resultsByBuilder[build])
        return;
    }

    tableHeaders.shift();
    if (currentState.tests) {
      tableHeaders.unshift('builder');
      generatePageForIndividualTests(currentState.tests.split(','));
    } else {
      tableHeaders.unshift('test');
      generatePageForBuilder(currentState.builder);
    }
  }

  function generatePageForIndividualTests(tests) {
    // TODO: Add link to trac from individual test page
    // TODO: Make links on builder pages to tests be to the individual test page
    for (var builder in builders)
      processTestRunsForBuilder(builder);

    var html = getHTMLForNavBar() +
      '<b>IF A BUILDER IS NOT LISTED THAT MEANS THE ' +
      'BUILDER DOES NOT RUN THAT TEST OR ALL RUNS OF THE TEST PASSED.</b>';

    for (var i = 0; i < tests.length; i++) {
      html += '<h2>' + tests[i] + '</h2>';

      var testResults = testToResultsMap[tests[i]];
      if (testResults && testResults.length) {
        var tableRowsHTML = '';
        for (var j = 0; j < testResults.length; j++) {
          tableRowsHTML += getHTMLForSingleTestRow(testResults[j].results,
              testResults[j].builder, true);
        }
        html += getHTMLForTestTable(tableRowsHTML);
      } else {
        html +='<div class="not-found">Test not found. Either it does not ' +
            'exist or it passes on all platforms.</div>';
      }
    }
    setFullPageHTML(html);

    $('tests-input').value = currentState.tests;
  }

  function getHTMLForNavBar(opt_builderName) {
    var html = '<div id=builders>';
    for (var builder in builders) {
      var className = builder == opt_builderName ? 'current-builder' : 'link';
      html += '<span class=' + className +
          ' onclick=\'setState("builder", "' + builder + '")\'>' +
          builder + '</span>';
    }
    html += '</div>' +
        '<form id=tests-form ' +
        'onsubmit="setState(\'tests\', tests.value);return false;">' +
        '<div>Show tests on all platforms (slow): </div><input name=tests ' +
        'placeholder="LayoutTests/foo/bar.html,LayoutTests/foo/baz.html" ' +
        'id=tests-input></form><div id="loading-ui">LOADING...</div>' +
        '<div id=legend>';

    for (var expectation in EXPECTATIONS_MAP) {
      html += '<div class=' + expectation + '>' +
          EXPECTATIONS_MAP[expectation] + '</div>';
    }
    return html + '<div class=wrong-expectations>WRONG EXPECTATIONS</div>' +
        '</div>';
  }

  function getLinkHTMLToToggleState(key, linkText) {
    var isTrue = currentState[key];
    return '<span class=link onclick="setState(\'' + key + '\', ' + !isTrue +
        ')">' + (isTrue ? 'Hide' : 'Show') + ' ' + linkText + '</span> | ';
  }

  function generatePageForBuilder(builderName) {
    processTestRunsForBuilder(builderName);

    var tableRowsHTML = '';
    var results = perBuilderFailures[builderName];
    sortTests(results, currentState.sortColumn, currentState.sortOrder);
    for (var i = 0; i < results.length; i++) {
      tableRowsHTML += getHTMLForSingleTestRow(results[i], builderName);
    }

    var testsHTML = tableRowsHTML ? getHTMLForTestTable(tableRowsHTML) :
        '<div>No tests. Try showing tests with correct expectations.</div>';

    var html = getHTMLForNavBar(builderName) +
        getHTMLForTestsWithExpectationsButNoFailures(builderName) +
        '<h2>Failing tests</h2><div>' +
        getLinkHTMLToToggleState('showWontFix', 'WONTFIX tests')  +
        getLinkHTMLToToggleState('showCorrectExpectations',
            'tests with correct expectations') +
        getLinkHTMLToToggleState('showFlaky', 'flaky tests') +
        '<form id=max-results-form ' +
        'onsubmit="setState(\'maxResults\', maxResults.value);return false;"' +
        '><span>Max results to show: </span>' +
        '<input name=maxResults id=max-results-input></form> | ' +
        '<b>All columns are sortable. | Skipped tests are not listed. | ' +
        'Flakiness reader order is newer --> older runs.</b></div>' +
        testsHTML;

    setFullPageHTML(html);

    var ths = document.getElementsByTagName('th');
    for (var i = 0; i < ths.length; i++) {
      ths[i].addEventListener('click', changeSort, false);
      ths[i].className = "sortable";
    }

    $('max-results-input').value = currentState.maxResults;
  }

  var singleBuilderViewParameters = ['sortOrder', 'sortColumn', 'showWontFix',
      'showCorrectExpectations', 'showFlaky: true', 'maxResults'];

  /**
   * Sets the page state and regenerates the page. Takes varargs of key, value
   * pairs.
   */
  function setState(key, value) {
    for (var i = 0; i < arguments.length; i = i + 2) {
      var key = arguments[i];
      if (key == 'tests') {
        for (var state in singleBuilderViewParameters) {
          delete currentState[state];
        }
      } else {
        delete currentState.tests;
      }

      currentState[key] = arguments[i + 1];
    }
    window.location.replace(getPermaLinkURL());
    handleLocationChange();
  }

  function handleLocationChange() {
    $('loading-ui').style.display = 'block';
    setTimeout(function() {
      oldLocation = window.location.href;
      generatePage();
    }, 0);
  }

  function getPermaLinkURL() {
    return window.location.pathname + '#' + joinParameters(currentState);
  }

  function joinParameters(stateObject) {
    var state = [];
    for (var key in stateObject) {
      state.push(key + '=' + encodeURIComponent(stateObject[key]));
    }
    return state.join('&');
  }

  function logTime(msg, startTime) {
    console.log(msg + ': ' + (Date.now() - startTime));
  }

  window.onload = function() {
    // This doesn't seem totally accurate as there is a race between
    // onload firing and the last script tag being executed.
    logTime('Time to load JS', pageLoadStartTime);
    setInterval(function() {
      if (oldLocation != window.location.href) {
        parseAllParameters();
        handleLocationChange();
      }
    }, 100);
  }
  </script>
</head>

<body></body>
</html>
