<!DOCTYPE HTML>
<html>

<head>
  <title>Webkit Layout Test History</title>
  <style>
    body {
      font-family: arial;
      font-size: 13px;
    }
    h2 {
      font-size: 16px;
      margin-bottom: .25em;
    }
    h3 {
      font-size: 13px;
      margin: 0;
    }
    #max-results-form {
      display: inline;
    }
    #max-results-input {
      width: 30px;
    }
    #tests-form {
      display: -webkit-box;
    }
    #tests-form > * {
      display: -webkit-box;
    }
    #tests-form > div {
      -webkit-box-flex: 0;
    }
    #tests-input {
      -webkit-box-flex: 1;
    }
    .test-link {
      white-space: normal;
    }
    .test-link, .options-container {
      padding: 0 2px;
    }
    .test-table {
      white-space: nowrap;
    }
    .test-table {
      width: 100%;
    }
    .test-table tr {
      border: 1px solid red;
      background-color: #E8E8E8;
    }
    .test-table tbody tr:hover {
      opacity: .7;
    }
    .test-table th {
      -webkit-user-select: none;
      -moz-user-select: none;
    }
    .link, .sortable .header-text {
      color: blue;
      text-decoration: underline;
      cursor: pointer;
    }
    .table-header-content,
    .table-header-content * {
      display: -webkit-box;
    }
    .table-header-content * {
      -webkit-box-flex: 1;
      cursor: pointer;
      white-space: normal;
    }
    .results {
      cursor: pointer;
      padding: 0;
      font-size: 10px;
      text-align: center;
    }
    #legend {
      position: fixed;
      top: 5px;
      right: 5px;
      width: 130px;
      border: 2px solid grey;
      background-color: white;
    }
    #legend-contents * {
      margin: 3px;
      padding: 0 2px;
    }
    body > div > :not(#legend) {
      margin-right: 145px;
    }
    #builders * {
      margin: 0 5px;
      display: inline-block;
      white-space: nowrap;
    }
    .test-table .wrong-expectations,
    .wrong-expectations {
      background-color: #pink;
    }
    .P {
      background-color: #8fdf5f;
    }
    .N {
      background-color: #e0b0ff;
    }
    .C {
      background-color: #ffc343;
    }
    .T {
      background-color: #fffc6c;
    }
    .I {
      background-color: #96f;
    }
    .S {
      background-color: #c6c;
    }
    .F {
      background-color: #e98080;
    }
    .O {
      background-color: #69f;
    }
    .merge {
      background-color: grey;
    }
    :not(#legend-contents) > .merge {
      width: 1px;
    }
    .separator {
      border: 1px solid lightgray;
      height: 0px;
    }
    .different-platform {
      color: gray;
      font-size: 10px;
    }
    .current-builder {
      font-weight: bold;
    }
    #passing-tests {
      -webkit-column-count: 3;
      -webkit-column-gap: 25px;
      -webkit-column-rule: 1px dashed black;
      -moz-column-count: 3;
      -moz-column-gap: 25px;
      -moz-column-rule: 1px dashed black;
    }
    .not-found {
      color: red;
      font-size: large;
    }
    #loading-ui {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      background-color: yellow;
      padding: 5px;
      text-align: center;
      font-weight: bold;
    }
    #popup {
      background-color: white;
      z-index: 1;
      position: absolute;
      border: 3px solid grey;
      padding: 3px;
      -webkit-box-shadow: 5px 5px 5px rgba(0, 0, 0, 0.5);
      -moz-box-shadow: 5px 5px 5px rgba(0, 0, 0, 0.5);
      -webkit-border-radius: 5px;
      -moz-border-radius: 5px;
    }
    #popup > ul {
      margin: 0;
      padding-left: 20px;
    }
  </style>

  <script src="dashboards/dashboard_base.js"></script>
  <script>
  /**
   * @fileoverview Creates a dashboard for multiple runs of a given set of tests
   * on the buildbots. Pulls in JSONP-ish files with the results for running
   * tests on a given builder (i.e. ADD_RESULTS(json_here)) and the expectations
   * for all tests on all builders (i.e. ADD_EXPECTATIONS(json_here)).
   *
   * This shows flakiness of the tests as well as runtimes for slow tests.
   *
   * Also, each column in the dashboard is sortable.
   *
   * Currently, only webkit tests are supported, but adding other test types
   * should just require the following steps:
   *   -generate results.json and expectations.json for these tests
   *   -copy them to the appropriate location
   *   -add the builder name to the list of builders below.
   */

  //////////////////////////////////////////////////////////////////////////////
  // CONSTANTS
  //////////////////////////////////////////////////////////////////////////////
  var ALL = 'ALL';
  var FORWARD = 'forward';
  var BACKWARD = 'backward';
  var TEST_URL_BASE_PATH =
      'http://trac.webkit.org/projects/webkit/browser/trunk/';
  var BUILDERS_BASE_PATH =
      'http://build.chromium.org/buildbot/waterfall/builders/';
  var TEST_RESULTS_BASE_PATH =
      'http://build.chromium.org/buildbot/layout_test_results/';
  var PLATFORMS = {
    'MAC': 'MAC',
    'LINUX': 'LINUX',
    'WIN': 'WIN',
    'WIN-XP': 'WIN-XP',
    'WIN-VISTA': 'WIN-VISTA'
  };
  var PLATFORM_FALLBACKS = {
    'WIN': 'ALL',
    'WIN-XP': 'WIN',
    'WIN-VISTA': 'WIN',
    'LINUX': 'ALL',
    'MAC': 'ALL'
  };
  var BUILD_TYPES = {'DEBUG': 'DBG', 'RELEASE': 'RELEASE'};
  var BASE_TABLE_HEADERS = ['bugs', 'modifiers', 'expectations', 'missing',
      'extra', 'slowest run', 'flakiness (numbers are runtimes in seconds)'];

  //////////////////////////////////////////////////////////////////////////////
  // Methods and objects from dashboard_base.js to override.
  //////////////////////////////////////////////////////////////////////////////
  function generatePage() {
    if (!currentState.tests && !('builder' in currentState)) {
      for (var builder in builders) {
        currentState.builder = builder;
        break;
      }
    }

    if (currentState.tests) {
      createTableHeadersArray('builder');
      generatePageForIndividualTests(getIndividualTests());
    } else {
      createTableHeadersArray('test');
      generatePageForBuilder(currentState.builder);
    }

    $('max-results-input').value = currentState.maxResults;
    updateLegendDisplay();

    for (var builder in builders) {
      processTestResultsForBuilderAsync(builder);
    }
  }

  function handleValidHashParameter(key, value) {
    switch(key) {
      case 'tests':
        validateParameter(currentState, key, value,
            function() {
              return isValidName(value);
            });

        return true;

      case 'builder':
        validateParameter(currentState, key, value,
            function() {
              return value in builders;
            });

        return true;

      case 'sortColumn':
        validateParameter(currentState, key, value,
            function() {
              for (var i = 0; i < BASE_TABLE_HEADERS.length; i++) {
                if (value ==
                        getSortColumnFromTableHeader(BASE_TABLE_HEADERS[i]))
                  return true;
              }
              return value == 'test' || value == 'builder';
            });

        return true;

      case 'sortOrder':
        validateParameter(currentState, key, value,
            function() {
              return value == FORWARD || value == BACKWARD;
            });

        return true;

      case 'maxResults':
        validateParameter(currentState, key, value,
            function() {
              return value.match(/^\d+$/)
            });

        return true;

      case 'showWontFix':
      case 'showCorrectExpectations':
      case 'showFlaky':
      case 'showLegend':
      case 'showSkipped':
        currentState[key] = value == 'true';

        return true;

      default:
        return false;
    }
  }

  defaultStateValues = {
    sortOrder: BACKWARD,
    sortColumn: 'flakiness',
    showWontFix: false,
    showCorrectExpectations: false,
    showLegend: true,
    showFlaky: true,
    showSkipped: false,
    maxResults: 200,
  };

  //////////////////////////////////////////////////////////////////////////////
  // GLOBALS
  //////////////////////////////////////////////////////////////////////////////

  // Text to put inside the header for each column of the test table.
  var tableHeaders;
  var perBuilderPlatformAndBuildType = {};
  var perBuilderFailures = {};
  // Map of builder to arrays of tests that are listed in the expectations file
  // but have for that builder.
  var perBuilderWithExpectationsButNoFailures = {};
  // Map of builder to arrays of paths that are skipped. This shows the raw
  // path used in test_expectations.txt rather than the test path since we
  // don't actually have any data here for skipped tests.
  var perBuilderSkippedPaths = {};
  // Maps test path to an array of {builder, testResults} objects.
  var testToResultsMap = {};

  function createResultsObjectForTest(test) {
    return {
      test: test,
      // HTML for display of the results in the flakiness column
      html: '',
      flips: 0,
      slowestTime: 0,
      meetsExpectations: true,
      isWontFix: false,
      // Sorted string of missing expectations
      missing: '',
      // String of extra expectations (i.e. expectations that never occur).
      extra: '',
      // HTML for bug IDs for this test for all platforms
      bugsHTML: '',
      // HTML for expectations for this test for all platforms
      expectationsHTML: '',
      // HTML for modifiers for this test for all platforms
      modifiersHTML: '',
      rawResults: ''
    };
  }

  function getMatchingElement(stringToMatch, elementsMap) {
    for (var element in elementsMap) {
      if (stringContains(stringToMatch, elementsMap[element]))
        return element;
    }
  }

  function getPlatFormAndBuildType(builderName) {
    if (!perBuilderPlatformAndBuildType[builderName]) {
      // If the build name does not contain a platform
      // or build type, assume Windows Release.
      var currentBuildUppercase = builderName.toUpperCase();
      var platform = getMatchingElement(currentBuildUppercase, PLATFORMS) ||
          'WIN-XP';
      var buildType = getMatchingElement(currentBuildUppercase, BUILD_TYPES) ||
          'RELEASE';
      perBuilderPlatformAndBuildType[builderName] = {platform: platform,
          buildType: buildType};
    }
    return perBuilderPlatformAndBuildType[builderName];
  }

  /**
   * Returns the expectation string for the given single character result.
   * This string should match the expectations that are put into
   * test_expectations.py.
   *
   * For example, if we start explicitly listing IMAGE result failures,
   * this function should start returning 'IMAGE'.
   */
  function getExpectationsFileStringForResult(result) {
    // For the purposes of comparing against the expecations of a test,
    // consider image/simplified diff failures as just failures since
    // the test_expectations file doesn't treat them specially.
    if (result == 'F' || result == 'S' || result == 'I')
      return 'FAIL';

    if (result == 'N' || result == 'O')
      return '';

    return EXPECTATIONS_MAP[result];
  }

  // Map of all tests to true values. This is just so we can have the list of
  // all tests across all the builders.
  var allTests;

  /**
   * Returns a map of all tests to true values. This is just so we can have the
   * list of all tests across all the builders.
   */
  function getAllTests() {
    if (!allTests) {
      allTests = {};
      for (var builder in builders) {
        addTestsForBuilder(builder, allTests);
      }
    }
    return allTests;
  }

  /**
   * Returns an array of tests to be displayed in the individual tests view.
   * Note that a directory can be listed as a test, so we expand that into all
   * tests in the directory.
   */
  function getIndividualTests() {
    if (!currentState.tests) {
      return [];
    }
    var separator = stringContains(currentState.tests, ' ') ? ' ' : ',';
    var testList = currentState.tests.split(separator);
    var tests = [];
    for (var i = 0; i < testList.length; i++) {
      var path = testList[i];
      if (!isDirectory(path)) {
        tests.push(path);
      } else {
        // Loop over all tests and find the ones that are in the directory.
        var allTests = getAllTests();
        for (var test in allTests) {
          if (stringContains(test, path)) {
            tests.push(test);
          }
        }
      }
    }
    return tests;
  }

  /**
   * Adds all the tests for the given builder to the testMapToPopulate.
   */
  function addTestsForBuilder(builder, testMapToPopulate) {
    var tests = resultsByBuilder[builder].tests;
    for (var test in tests) {
      testMapToPopulate[test] = true;
    }
  }

  // Map of all tests to true values by platform and build type.
  // e.g. allTestsByPlatformAndBuildType['WIN']['DEBUG'] will have the union
  // of all tests run on the win-debug builders.
  var allTestsByPlatformAndBuildType = {};
  for (var platform in PLATFORMS) {
    allTestsByPlatformAndBuildType[platform] = {};
  }

  /**
   * Map of all tests to true values by platform and build type.
   * e.g. allTestsByPlatformAndBuildType['WIN']['DEBUG'] will have the union
   * of all tests run on the win-debug builders.
   */
  function getAllTestsWithSamePlatformAndBuildType(platform, buildType) {
    if (!allTestsByPlatformAndBuildType[platform][buildType]) {
      var tests = {};
      for (var thisBuilder in builders) {
        var thisBuilderBuildInfo = getPlatFormAndBuildType(thisBuilder);
        if (thisBuilderBuildInfo.buildType == buildType &&
            thisBuilderBuildInfo.platform == platform) {
          addTestsForBuilder(thisBuilder, tests);
        }
      }
      allTestsByPlatformAndBuildType[platform][buildType] = tests;
    }

    return allTestsByPlatformAndBuildType[platform][buildType];
  }

  function addHTMLToIndividualOptionsArray(array, html, isCurrentPlatform) {
    if (html) {
      array.push('<div class="option' +
          (isCurrentPlatform ? '' : ' different-platform') + '">' + html +
          '</div>');
    }
  }

  function addHtmlToOptionsArrays(htmlArrays, expectations, modifiers, bugs,
      isCurrentPlatform) {
    addHTMLToIndividualOptionsArray(htmlArrays.expectations, expectations,
        isCurrentPlatform);
    addHTMLToIndividualOptionsArray(htmlArrays.modifiers, modifiers,
        isCurrentPlatform);
    addHTMLToIndividualOptionsArray(htmlArrays.bugs, getHtmlForBugs(bugs),
        isCurrentPlatform);
  }

  function getExpectations(test, platform, buildType) {
    var testObject = allExpectations[test];
    if (!testObject)
      return null;

    var platformObject;
    while (platform && !(platformObject = testObject[platform])) {
      platform = PLATFORM_FALLBACKS[platform];
    }

    if (platformObject) {
      return platformObject[buildType] || platformObject[ALL];
    }
    return null;
  }

  function populateExpectationsData(resultsObj, platform, buildType, builder) {
    var test = resultsObj.test;
    var thisPlatformExpectations = getExpectations(test, platform, buildType);

    var htmlArrays = {};
    htmlArrays.expectations = [];
    htmlArrays.modifiers = [];
    htmlArrays.bugs = [];

    var tests = resultsByBuilder[builder].tests;

    var testObject = allExpectations[test];
    var usedExpectations = {};

    for (var platform in allExpectations[test]) {
      var platformObject = testObject[platform];
      for (var buildType in platformObject) {
        var thisExpectations = platformObject[buildType];
        var modifiers = thisExpectations.modifiers;

        // A set of modifiers/expectations can apply to multiple platforms.
        // Only add HTML for each entry once.
        if (usedExpectations[modifiers])
          continue;

        usedExpectations[modifiers] = true;

        var bugs = modifiers.match(/BUG\d+/g);
        if (bugs) {
          for (var j = 0; j < bugs.length; j++) {
            modifiers = modifiers.replace(bugs[j], '');
          }
          modifiers = trimString(modifiers);
          bugs = bugs.join(' ');
        } else {
          bugs = '';
        }

        var expectations = thisExpectations.expectations;
        if (thisExpectations == thisPlatformExpectations) {
          resultsObj.bugs = bugs;
          resultsObj.expectations = expectations;
          resultsObj.modifiers = modifiers;
          resultsObj.isWontFix = stringContains(modifiers, 'WONTFIX');
        } else {
          addHtmlToOptionsArrays(htmlArrays, expectations, modifiers, bugs,
              false);
        }
      }
    }

    if (resultsObj.expectations) {
      addHtmlToOptionsArrays(htmlArrays, resultsObj.expectations,
          resultsObj.modifiers, resultsObj.bugs, true);
    }

    resultsObj.bugsHTML += htmlArrays.bugs.join('<div class=separator></div>');
    resultsObj.expectationsHTML +=
        htmlArrays.expectations.join('<div class=separator></div>');
    resultsObj.modifiersHTML +=
        htmlArrays.modifiers.join('<div class=separator></div>');
  }

  function addFallbacks(addFn, candidates, validValues) {
    var hasAnyValidValues = false;
    for (var i = 0; i < candidates.length; i++) {
      if (candidates[i] in validValues) {
        hasAnyValidValues = true;
        addFn(candidates[i]);
      }
    }
    if (!hasAnyValidValues)
      addFn(ALL);
  }

  function addTestToAllExpectations(test, expectations) {
    if (!allExpectations[test])
      allExpectations[test] = {};

    var testHolder = allExpectations[test];

    for (var j = 0; j < expectations.length; j++) {
      var modifiers = expectations[j].modifiers.split(' ');
      addFallbacks(function(platformKey) {
        if (!testHolder[platformKey])
          testHolder[platformKey] = {}

        var platformHolder = testHolder[platformKey];
        addFallbacks(function(buildTypeKey) {
          platformHolder[buildTypeKey] = expectations[j];
        }, modifiers, BUILD_TYPES);
      }, modifiers, PLATFORMS);
    }
  }

  /**
   * Data structure to hold the processed expectations.
   * allExpectations[testPath][platform][buildType] gets the object that has
   * expectations and modifiers properties for this platform/buildType.
   *
   * platform and buildType both go through fallback sets of keys from most
   * specific key to least specific. For example, on Windows Vista, we first
   * check the platform WIN-VISTA, if there's no such object, we check WIN,
   * then finally we check ALL. For build types, we check the current
   * buildType, then ALL.
   */
  var allExpectations;

  function processExpectations() {
    if (allExpectations)
      return allExpectations;

    allExpectations = {};

    var expectationsArray = [];
    for (var path in expectationsByTest) {
      expectationsArray.push(
          {path: path, expectations: expectationsByTest[path]});
    }

    // Sort the array to hit more specific paths last. More specific
    // paths (e.g. foo/bar/baz.html) override entries for less-specific ones
    // (e.g. foo/bar).
    expectationsArray.sort();

    var allTests = getAllTests();
    for (var i = 0; i < expectationsArray.length; i++) {
      var path = expectationsArray[i].path;
      var expectations = expectationsArray[i].expectations;

      var pathMatchesAnyTest = false;
      if (allTests[path]) {
        pathMatchesAnyTest = true;
        addTestToAllExpectations(path, expectations);
      } else {
        for (var test in allTests) {
          if (stringContains(test, path)) {
            pathMatchesAnyTest = true;
            addTestToAllExpectations(test, expectations);
          }
        }
      }

      if (!pathMatchesAnyTest)
        addTestToAllExpectations(path, expectations);
    }
  }

  function processMissingTestsWithExpectations(builder, platform, buildType) {
    var noFailures = [];
    var skipped = [];

    var allTestsForPlatformAndBuildType =
        getAllTestsWithSamePlatformAndBuildType(platform, buildType);
    for (var test in allExpectations) {
      var expectations = getExpectations(test, platform, buildType);

      if (!expectations)
        continue;

      // Test has expectations, but no result in the builders results.
      // This means it's either SKIP or they pass on on builds.
      if (!allTestsForPlatformAndBuildType[test] &&
          !stringContains(expectations.modifiers, 'WONTFIX')) {
        if (stringContains(expectations.modifiers, 'SKIP')) {
          skipped.push(test);
        } else if (!expectations.expectations.match(/^\s*PASS\s*$/)) {
          // Don't show tests expected to always pass. This is used in ways like
          // the following:
          // LayoutTests/foo/bar = FAIL
          // LayoutTests/foo/bar/baz.html = PASS
          noFailures.push(test);
        }
      }
    }

    perBuilderSkippedPaths[builder] = skipped.sort();
    perBuilderWithExpectationsButNoFailures[builder] = noFailures.sort();
  }

  function processTestResultsForBuilderAsync(builder) {
    setTimeout(function() {
        processTestRunsForBuilder(builder);
      }, 0);
  }

  function processTestRunsForBuilder(builderName) {
    if (perBuilderFailures[builderName])
      return;

    var start = Date.now();
    processExpectations();

    var buildInfo = getPlatFormAndBuildType(builderName);
    var platform = buildInfo.platform;
    var buildType = buildInfo.buildType;
    processMissingTestsWithExpectations(builderName, platform, buildType);

    var failures = [];
    var allTestsForThisBuilder = resultsByBuilder[builderName].tests;

    for (var test in allTestsForThisBuilder) {
      var resultsForTest = createResultsObjectForTest(test);
      populateExpectationsData(resultsForTest, platform, buildType,
          builderName);

      var rawTest = resultsByBuilder[builderName].tests[test];
      resultsForTest.rawTimes = rawTest.times;
      var rawResults = rawTest.results;
      resultsForTest.rawResults = rawResults;
      resultsForTest.flips = rawResults.length - 1;

      var unexpectedExpectations = [];
      var resultsMap = {}
      var numResultsSeen = 0;
      for (var i = 0;
           i < rawResults.length && numResultsSeen < currentState.maxResults;
           i++) {
        numResultsSeen += rawResults[i][0];
        var expectation = getExpectationsFileStringForResult(rawResults[i][1]);
        resultsMap[expectation] = true;
      }

      var expectationsArray = resultsForTest.expectations ?
          resultsForTest.expectations.split(' ') : [];
      var extraExpectations = expectationsArray.filter(
          function(element) {
              return element && !resultsMap[element] &&
                  !stringContains(element, 'BUG');
          });

      var missingExpectations = [];
      for (var result in resultsMap) {
        var hasExpectation = false;
        for (var i = 0; i < expectationsArray.length; i++) {
          if (result == expectationsArray[i])
            hasExpectation = true;
        }
        if (!hasExpectation)
          missingExpectations.push(result);
      }

      var times = resultsByBuilder[builderName].tests[test].times;
      var numResultsSeen = 0;
      for (var i = 0;
           i < times.length && numResultsSeen < currentState.maxResults;
           i++) {
        numResultsSeen += times[i][0];
        resultsForTest.slowestTime = Math.max(resultsForTest.slowestTime,
            times[i][1]);
      }

      if (resultsForTest.slowestTime && !resultsMap['TIMEOUT'] &&
          (!resultsForTest.expectations ||
           !stringContains(resultsForTest.expectations, 'TIMEOUT')) &&
          (!resultsForTest.modifiers ||
           !stringContains(resultsForTest.modifiers, 'SLOW'))) {
        missingExpectations.push('SLOW');
      }

      resultsForTest.meetsExpectations =
          !missingExpectations.length && !extraExpectations.length;
      resultsForTest.missing = missingExpectations.sort().join(' ');
      resultsForTest.extra = extraExpectations.sort().join(' ');

      failures.push(resultsForTest);

      if (!testToResultsMap[test])
        testToResultsMap[test] = [];
      testToResultsMap[test].push(
          {builder: builderName, results: resultsForTest});
    }

    perBuilderFailures[builderName] = failures;
    logTime('processTestRunsForBuilder: ' + builderName, start);
  }

  var bugUrlPrefix = '<a href="http://';
  var bugUrlPostfix = '/$1">$1</a> ';
  var internalBugReplaceValue = bugUrlPrefix + 'b' + bugUrlPostfix;
  var externalBugReplaceValue = bugUrlPrefix + 'crbug.com' + bugUrlPostfix;

  /**
   * Returns the BUG modifiers linking to the bug.
   * Bugs with 4 or 5 digits are crbug.com bugs. Bugs with 6 or 7 digits
   * are internal google bugs.
   */
  function getHtmlForBugs(bugs) {
    bugs = bugs.replace(/BUG(\d{4})(\ |$)/g, externalBugReplaceValue);
    bugs = bugs.replace(/BUG(\d{5})(\ |$)/g, externalBugReplaceValue);
    bugs = bugs.replace(/BUG(\d{6})(\ |$)/g, internalBugReplaceValue);
    bugs = bugs.replace(/BUG(\d{7})(\ |$)/g, internalBugReplaceValue);
    return bugs;
  }

  function getLinkHTMLToOpenWindow(url, text) {
    return '<div class=link onclick="window.open(\'' + url + '\')">' + text +
        '</div>';
  }

  function createBlameListHTML(revisions, index, urlBase, separator, repo) {
    var thisRevision = revisions[index];
    if (!thisRevision)
      return '';

    var previousRevision = revisions[index + 1];
    if (previousRevision && previousRevision != thisRevision) {
      previousRevision++;
      return getLinkHTMLToOpenWindow(
          urlBase + thisRevision + separator + previousRevision,
          repo + ' blamelist r' + previousRevision + ':r' + thisRevision);
    } else {
      return 'At ' + repo + ' revision: ' + thisRevision;
    }
  }

  function showPopupForBuild(e, builder, index) {
    var html = '';

    var time = resultsByBuilder[builder].secondsSinceEpoch[index];
    if (time) {
      var date = new Date(time * 1000);
      html += date.toLocaleDateString() + ' ' + date.toLocaleTimeString();
    }

    html += '<ul><li>' +
      createBlameListHTML(resultsByBuilder[builder].webkitRevision, index,
          'http://trac.webkit.org/log/?rev=', '&stop_rev=', 'WebKit') +
      '</li><li>' +
      createBlameListHTML(resultsByBuilder[builder].chromeRevision, index,
          'http://build.chromium.org/buildbot/perf/dashboard/ui/' +
          'changelog.html?url=/trunk/src&mode=html&range=', ':', 'Chrome') +
      '</li>';

    var chromeRevision = resultsByBuilder[builder].chromeRevision[index];
    if (chromeRevision) {
      html += '<li><a href="' + TEST_RESULTS_BASE_PATH + builders[builder] +
          '/' + chromeRevision + '/layout-test-results.zip' +
          '">layout-test-results.zip</a></li>';
    }

    var buildNumbers = resultsByBuilder[builder].buildNumbers;
    html += '<li>' +
        getLinkHTMLToOpenWindow(BUILDERS_BASE_PATH + builder + '/builds/' +
        buildNumbers[index], 'Build log and blamelist') + '</li></ul>';

    showPopup(e, html);
  }

  function showPopupForTest(e, test) {
    showPopup(e, getHTMLForIndividulTestOnAllBuilders(test));
  }

  function getHtmlForTestResults(test, builder) {
    var html = '';
    var results = test.rawResults.concat();
    var times = test.rawTimes.concat();
    var buildNumbers = resultsByBuilder[builder].buildNumbers;

    var indexToReplaceCurrentResult = -1;
    var indexToReplaceCurrentTime = -1;
    var currentResultArray, currentTimeArray, currentResult, innerHTML;
    var maxIndex = Math.min(buildNumbers.length, currentState.maxResults);
    for (var i = 0; i < maxIndex; i++) {
      if (i > indexToReplaceCurrentResult) {
        currentResultArray = results.shift();
        if (currentResultArray) {
          currentResult = currentResultArray[1];
          indexToReplaceCurrentResult += currentResultArray[0];
        } else {
          currentResult = 'N';
          indexToReplaceCurrentResult += buildNumbers.length;
        }
      }

      if (i > indexToReplaceCurrentTime) {
        currentTimeArray = times.shift();
        var currentTime = 0;
        if (currentResultArray) {
          currentTime = currentTimeArray[1];
          indexToReplaceCurrentTime += currentTimeArray[0];
        } else {
          indexToReplaceCurrentTime += buildNumbers.length;
        }
        innerHTML = currentTime || '&nbsp;';
      }

      html += '<td title="Click results for handy links." class="results ' +
          currentResult + '" onclick=\'showPopupForBuild(event, "' + builder +
          '",' + i + ')\'>' + innerHTML + '</td>';

      var webkitRevision = resultsByBuilder[builder].webkitRevision;
      var isWebkitMerge = webkitRevision[i + 1] &&
          webkitRevision[i] != webkitRevision[i + 1];
      if (isWebkitMerge)
        html += '<td class=merge></td>';
    }
    return html;
  }

  function getHTMLForTestsWithExpectationsButNoFailures(builder) {
    var tests = perBuilderWithExpectationsButNoFailures[builder];
    var skippedPaths = perBuilderSkippedPaths[builder];

    var html = '';
    if (tests.length || skippedPaths.length) {
      var buildInfo = getPlatFormAndBuildType(builder);
      html += '<h2>Expectations for ' + buildInfo.platform + '-' +
          buildInfo.buildType + ':</h2>';
    }

    var open = '<div onclick="selectContents(this)">';

    if (tests.length) {
      html +=  '<h3>Have not failed in last ' +
          resultsByBuilder[builder].buildNumbers.length +
          ' runs.</h3><div id="passing-tests">' + open +
          tests.join('</div>' + open) + '</div></div>';
    }

    if (skippedPaths.length) {
      html += '<h3>' +
          getLinkHTMLToToggleState('showSkipped',
              'Skipped tests in text_expectations.txt') +
          '</h3>';

      if (currentState.showSkipped) {
        html += '<div id="passing-tests">' + open +
          skippedPaths.join('</div>' + open) + '</div></div>';
      }
    }
    return html;
  }

  /**
   * Returns true if a test should be considered flaky. Uses heuristics to
   * avoid common non-flaky cases.
   */
  function isTestFlaky(testResult) {
    return testResult.flips > 1 && !isFixedTest(testResult);
  }

  /**
   * Returns whether this tests results match the heuristic for new tests that
   * have been fixed. Specifically, a new test that fails a couple
   * times and then passes from then on would have results like PPPPFFFFNNNNN.
   * Where that middle part can be a series of F's, S's or I's for the
   * different types of failures.
   */
  function isFixedTest(testResult) {
    if (testResult.isFixedTest === undefined) {
      var results = testResult.rawResults;
      var isFixedTest = results[0][1] == 'P';
      var numResults = results[0][0];
      if (numResults < currentState.maxResults &&
          isFixedTest && results.length > 1) {
        // We don't care what the value of the second set of results is, just
        // how many results there are.
        numResults += results[1][0];
      }
      if (numResults < currentState.maxResults &&
          isFixedTest && results.length > 2) {
        isFixedTest = results.length == 3 && results[2][1] == 'N';
      }
      testResult.isFixedTest = isFixedTest;
    }
    return testResult.isFixedTest;
  }

  /**
   * Returns whether the test has passed continuously for at
   * least as many runs as we are showing results for.
   */
   function hasPassedInMaxRuns(testResult) {
     var results = testResult.rawResults;
     return results[0][1] == 'P' && results[0][0] >= currentState.maxResults;
   }

  /**
   * Returns whether we should exclude test results from the test table.
   * Note that we never want to exclude tests when we're in the individual
   * tests view of the dashboard since the user is explicitly listing tests
   * to view.
   */
  function shouldHideTest(testResult) {
    if (currentState.tests)
      return false;

    if (testResult.isWontFix && !currentState.showWontFix)
      return true;

     if (hasPassedInMaxRuns(testResult)) {
      // Hide tests that are passing.
      return true;
    }

    if ((testResult.meetsExpectations || isFixedTest(testResult)) &&
        !currentState.showCorrectExpectations) {
      // Only hide flaky tests that match their expectations if showFlaky
      // is false.
      return !currentState.showFlaky || !isTestFlaky(testResult);
    }

    return !currentState.showFlaky && isTestFlaky(testResult);
  }

  /**
   * Sets the browser's selection to the element's contents.
   */
  function selectContents(element) {
    window.getSelection().selectAllChildren(element);
  }

  function getHTMLForSingleTestRow(test, builder, opt_isCrossBuilderView) {
    if (shouldHideTest(test)) {
      // The innerHTML call is considerably faster if we exclude the rows for
      // items we're not showing than if we hide them using display:none.
      return '';
    }

    // If opt_isCrossBuilderView is true, we're just viewing a single test
    // with results for many builders, so the first column is builder names
    // instead of test paths.
    var testCellHTML = opt_isCrossBuilderView ? builder :
      '<span class="link" onclick="showPopupForTest(event, \'' + test.test +
      '\');selectContents(this);return false;">' + test.test + '</span>';

    return '<tr class="' +
      (test.meetsExpectations ? '' : 'wrong-expectations') +
      // TODO(ojan): If a test is a chrome/ or a pending/ test, point to
      // src.chromium.org instead of trac.webkit.org.
      '"><td class=test-link>' + testCellHTML +
      '</td><td class=options-container>' + test.bugsHTML +
      '</td><td class=options-container>' + test.modifiersHTML +
      '</td><td class=options-container>' + test.expectationsHTML +
      '</td><td>' + test.missing +
      '</td><td>' + test.extra +
      '</td><td>' + (test.slowestTime ? test.slowestTime + 's' : '') +
      '</td>' + getHtmlForTestResults(test, builder) + '</tr>';
  }

  function getSortColumnFromTableHeader(headerText) {
    return headerText.split(' ', 1)[0];
  }

  function getHTMLForTestTable(rowsHTML) {
    var html = '<table class=test-table><thead><tr>';
    for (var i = 0; i < tableHeaders.length; i++) {
      // Use the first word of the header title as the sortkey
      var thisSortValue = getSortColumnFromTableHeader(tableHeaders[i]);
      var arrowHTML = thisSortValue == currentState.sortColumn ?
          '<span class=' + currentState.sortOrder + '>' +
          (currentState.sortOrder == FORWARD ? '&uarr;' : '&darr;' ) +
          '</span>' :
          '';
      html += '<th sortValue=' + thisSortValue +
          // Extend last th through all the rest of the columns.
          (i == tableHeaders.length - 1 ? ' colspan=10000' : '') +
          // Extra span here is so flex boxing actually centers.
          // There's probably a better way to do this with CSS only though.
          '><div class=table-header-content><span></span>' + arrowHTML +
          '<span class=header-text>' + tableHeaders[i] + '</span>' +
          arrowHTML + '</div></th>';
    }
    return html + '</tr></thead><tbody>' + rowsHTML + '</tbody></table>';
  }

  function setFullPageHTML(html) {
    var startTime = Date.now();
    // InnerHTML to a div that's not in the document. This is
    // ~300ms faster in Safari 4 and Chrome 4 on mac.
    var div = document.createElement('div');
    div.innerHTML = html;
    document.body.innerHTML = '';
    document.body.appendChild(div);
    logTime('Time to innerHTML', startTime);
  }

  function getAlphanumericCompare(column, reverse) {
    return getReversibleCompareFunction(function(a, b) {
      // Put null entries at the bottom
      var a = a[column] ? String(a[column]) : 'z';
      var b = b[column] ? String(b[column]) : 'z';

      if (a < b)
        return -1;
      else if (a == b)
        return 0;
      else
        return 1;
    }, reverse);
  }

  function getNumericSort(column, reverse) {
    return getReversibleCompareFunction(function(a, b) {
      a = parseFloat(a[column]);
      b = parseFloat(b[column]);
      return a - b;
    }, reverse);
  }

  function getReversibleCompareFunction(compare, reverse) {
    return function(a, b) {
      return compare(reverse ? b : a, reverse ? a : b);
    }
  }

  function changeSort(e) {
    var target = e.currentTarget;
    e.preventDefault();

    var sortValue = target.getAttribute('sortValue');
    while (target && target.tagName != 'TABLE') {
      target = target.parentNode;
    }

    var sort = 'sortColumn';
    var orderKey = 'sortOrder';
    if (sortValue == currentState[sort] && currentState[orderKey] == FORWARD)
      order = BACKWARD;
    else
      order = FORWARD;

    setState(sort, sortValue, orderKey, order);
  }

  function sortTests(tests, column, order) {
    var resultsProperty, sortFunctionGetter;
    if (column == 'flakiness') {
      sortFunctionGetter = getNumericSort;
      resultsProperty = 'flips';
    } else if (column == 'slowest') {
      sortFunctionGetter = getNumericSort;
      resultsProperty = 'slowestTime';
    } else {
      sortFunctionGetter = getAlphanumericCompare;
      resultsProperty = column;
    }

    tests.sort(sortFunctionGetter(resultsProperty, order == BACKWARD));
  }

  function getHTMLForIndividulTestOnAllBuilders(test) {
    for (var builder in builders)
      processTestRunsForBuilder(builder);

    var testResults = testToResultsMap[test];
    if (testResults && testResults.length) {
      var tracURL = TEST_URL_BASE_PATH + test
      var html = getLinkHTMLToOpenWindow(tracURL, tracURL) +
          '<div><b>If a builder is not listed, that means the builder does ' +
          'run that test or all runs of the test passed.</b></div>';

      for (var j = 0; j < testResults.length; j++) {
        html += getHTMLForSingleTestRow(testResults[j].results,
            testResults[j].builder, true);
      }
      return getHTMLForTestTable(html);
    } else {
      var html = '';
      if (expectationsByTest[test]) {
        for (var i = 0; i < expectationsByTest[test].length; i++) {
          html += '<div>' + expectationsByTest[test][i].modifiers + ' | ' +
              expectationsByTest[test][i].expectations + '</div>';
        }
      }
      return html + '<div class="not-found">Test not found. Either it does ' +
          'not exist, is skipped or passes on all platforms.</div>';
    }
  }

  function generatePageForIndividualTests(tests) {
    var html = getHTMLForNavBar();
    for (var i = 0; i < tests.length; i++) {
      html += '<h2>' + tests[i] + '</h2>' +
          getHTMLForIndividulTestOnAllBuilders(tests[i]);
    }
    setFullPageHTML(html);

    $('tests-input').value = currentState.tests;
  }

  function getHTMLForNavBar(opt_builderName) {
    var html = '<div id=builders>';
    for (var builder in builders) {
      var className = builder == opt_builderName ? 'current-builder' : 'link';
      html += '<span class=' + className +
          ' onclick=\'setState("builder", "' + builder + '")\'>' +
          builder + '</span>';
    }
    html += '</div>' +
        '<form id=tests-form ' +
        'onsubmit="setState(\'tests\', tests.value);return false;">' +
        '<div>Show tests on all platforms: </div><input name=tests ' +
        'placeholder="Comma or space-separated list of tests or partial ' +
        'paths to show test results across all builders, e.g., ' +
        'LayoutTests/foo/bar.html,LayoutTests/foo/baz,forms" ' +
        'id=tests-input></form>' +
        '<form id=max-results-form ' +
        'onsubmit="setState(\'maxResults\', maxResults.value);return false;"' +
        '><span>Number of results to show (max=500): </span>' +
        '<input name=maxResults id=max-results-input></form>' +
        '<div id="loading-ui">LOADING...</div><div id=legend>' +
        '<div id=legend-toggle>' + getLinkHTMLToToggleLegendDisplay() +
        '</div><div id=legend-contents>';

    for (var expectation in EXPECTATIONS_MAP) {
      html += '<div class=' + expectation + '>' +
          EXPECTATIONS_MAP[expectation] + '</div>';
    }
    return html + '<div class=wrong-expectations>WRONG EXPECTATIONS</div>' +
        '<div class=merge>WEBKIT MERGE</div></div></div>';
  }

  function getLinkHTMLToToggleState(key, linkText) {
    var isTrue = currentState[key];
    return '<span class=link onclick="setState(\'' + key + '\', ' + !isTrue +
        ')">' + (isTrue ? 'Hide' : 'Show') + ' ' + linkText + '</span>';
  }

  function generatePageForBuilder(builderName) {
    processTestRunsForBuilder(builderName);

    var tableRowsHTML = '';
    var results = perBuilderFailures[builderName];
    sortTests(results, currentState.sortColumn, currentState.sortOrder);
    for (var i = 0; i < results.length; i++) {
      tableRowsHTML += getHTMLForSingleTestRow(results[i], builderName);
    }

    var testsHTML = tableRowsHTML ? getHTMLForTestTable(tableRowsHTML) :
        '<div>No tests. Try showing tests with correct expectations.</div>';

    var html = getHTMLForNavBar(builderName) +
        getHTMLForTestsWithExpectationsButNoFailures(builderName) +
        '<h2>Failing tests</h2><div>' +
        getLinkHTMLToToggleState('showWontFix', 'WONTFIX tests') + ' | ' +
        getLinkHTMLToToggleState('showCorrectExpectations',
            'tests with correct expectations') + ' | ' +
        getLinkHTMLToToggleState('showFlaky', 'flaky tests') + ' | ' +
        '<b>All columns are sortable. | ' +
        'Flakiness reader order is newer --> older runs.</b></div>' +
        testsHTML;

    setFullPageHTML(html);

    var ths = document.getElementsByTagName('th');
    for (var i = 0; i < ths.length; i++) {
      ths[i].addEventListener('click', changeSort, false);
      ths[i].className = "sortable";
    }
  }

  function getLinkHTMLToToggleLegendDisplay() {
    return getLinkHTMLToToggleState('showLegend', 'Legend');
  }

  function updateLegendDisplay() {
    $('legend-contents').style.display = currentState.showLegend ? '' : 'none';
  }

  function createTableHeadersArray(firstColumnHeader) {
    tableHeaders = [firstColumnHeader].concat(BASE_TABLE_HEADERS);
  }

  /**
   * Clears the processed test state for perBuilderFailures.
   * TODO(ojan): This really should probably clear all the state we've
   * generated, but that's kind of a pain given the many global objects state is
   * stored in. There should probably be one global generatedState
   * object that all the generated state lives off of.
   */
  function clearProcessedTestState() {
    for (var builder in builders) {
      delete perBuilderFailures[builder];
      delete perBuilderPlatformAndBuildType[builder];
      delete perBuilderWithExpectationsButNoFailures[builder];
      delete perBuilderSkippedPaths[builder];
    }

    for (var key in testToResultsMap) {
      delete testToResultsMap[key]
    }
  }

  /**
   * Sets the page state and regenerates the page. Takes varargs of key, value
   * pairs.
   */
  function setState(var_args) {
    var shouldRegeneratePage = true;
    for (var i = 0; i < arguments.length; i += 2) {
      var key = arguments[i];

      if (key != 'tests' && key != 'maxResults') {
        delete currentState.tests;
      }

      if (key == 'maxResults') {
        // Processing the test results JSON makes assumptions about the number
        // of results to show. This makes changing the number of maxResults slow
        // but is considerably easier than refactoring all the other code.
        clearProcessedTestState();
      }

      if (key == 'showLegend') {
        // No need to regenerate the page if only the legend's display is being
        // updated.
        shouldRegeneratePage = keys.length == 1;
        updateLegendDisplay();
        $('legend-toggle').innerHTML = getLinkHTMLToToggleLegendDisplay();
      }
    }

    // Set all the custom state for this dashboard before calling
    // setQueryParameter since setQueryParameter updates the location bar.
    setQueryParameter.apply(null, arguments);

    if (shouldRegeneratePage)
      handleLocationChange();
  }


  </script>
</head>

<body></body>
</html>
